<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[ScheduledThreadPoolExecutor]]></title>
    <url>%2F2019%2F07%2F27%2FScheduledThreadPoolExecutor%2F</url>
    <content type="text"><![CDATA[ScheduledExecutorService简单看下其继承关系的类图如下： ExecutorExecutor定义了一个线程池的最核心的操作execute,帮助我们将任务提交和任务具体执行、调度进行解耦。1void execute(Runnable command);通过Executor而不是现实的创建线程(new Thread(RunnableTask()).start())：1234Executor executor = anExecutor();executor.execute(new RunnableTask1());executor.execute(new RunnableTask2());... ExecutorServiceExecutorService提供方法来管理线程池的关闭、提供Future来追踪一个或多个异步任务的执行进度。ExecutorService可以关闭拒绝新来的任务，其提供了两种关闭方式： shutdown() :关闭前允许之前提交的任务先执行完 shutdownNow():阻止等待的任务并尝试停止正在执行的任务submit()方法通过execute()实现并返回一个Future，可取消任务的执行或等待任务执行完成。invokeAny和invokeAll方法用于批量执行任务，等待至少一个或者全部任务执行完成。123456789101112131415161718void shutdown();List&lt;Runnable&gt; shutdownNow();boolean isShutdown();boolean isTerminated();boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);Future&lt;?&gt; submit(Runnable task);&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException;&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException;&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException, ExecutionException;&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; ScheduledExecutorServicescheduledExecutorService在ExecutorService的基础上加入了定时任务调度的特性,可以调度任务在给定延时执行或在固定周期内执行。schedule()可创建不同延迟的任务，并返回一个可取消或校验执行的ScheduledFuture&lt;?&gt;对象。scheduledAtFixedRate()和scheduledWithFixedDelay()方法创建周期性任务直达任务取消。 12345678910111213141516171819public ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit);public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit);/** * initialDelay初始延迟过后 周期性的执行任务 * 如果任务执行时间过长超过执行周期，后来的任务将延迟执行 * 不会并发执行 **/public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit);/** * 同样在initialDelay延迟后，开始周期性执行任务 * 按照前一个任务结束到后一个任务开始的 固定时间间隔执行 **/public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit); ScheduledThreadPoolExecutorScheduledThreadPoolExecutor是一个可以设置固定延迟或周期性执行任务的ThreadPoolExecutor。相对于Timer来说，当需要多个工作线程，或需要更加灵活 或需要ThreadPoolExecutor相关功能，ScheduledThreadPoolExecutor会更适合。 123456789101112131415161718192021222324252627282930public void execute(Runnable command) &#123; schedule(command, 0, NANOSECONDS);&#125;public ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit) &#123; if (command == null || unit == null) throw new NullPointerException(); RunnableScheduledFuture&lt;?&gt; t = decorateTask(command, new ScheduledFutureTask&lt;Void&gt;(command, null, triggerTime(delay, unit))); delayedExecute(t); return t;&#125;private void delayedExecute(RunnableScheduledFuture&lt;?&gt; task) &#123; if (isShutdown()) reject(task); else &#123; super.getQueue().add(task); if (isShutdown() &amp;&amp; !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp; remove(task)) task.cancel(false); else ensurePrestart(); &#125; &#125; ScheduledThreadPoolExecutor相对于ThreadPoolExecutor，通过将Runnable任务封装为ScheduledFutureTask,内部使用的BlockingQueue为自定义的DelayedWorkQueue来完成固定延迟或周期性调度任务，ScheduledFutureTask其类图如下： DelayedWorkQueue其源码类似于PriorityQueue，核心使用了最小堆来维护数据，加入删除数据时使用siftup和siftDown操作来保证最小堆的正确性。]]></content>
  </entry>
  <entry>
    <title><![CDATA[数据结构之Queue]]></title>
    <url>%2F2018%2F07%2F26%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BQueue%2F</url>
    <content type="text"><![CDATA[队列（queue）基本就是一个先进先出（FIFO）的数据结构。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123; /** * 向队列中新增一个元素，如果队列已满抛出IllegalStateException异常 */ boolean add(E e); /** * Inserts the specified element into this queue if it is possible to do * so immediately without violating capacity restrictions. * When using a capacity-restricted queue, this method is generally * preferable to &#123;@link #add&#125;, which can fail to insert an element only * by throwing an exception. */ boolean offer(E e); /** * Retrieves and removes the head of this queue. This method differs * from &#123;@link #poll poll&#125; only in that it throws an exception if this * queue is empty. * */ E remove(); /** * Retrieves and removes the head of this queue, * or returns &#123;@code null&#125; if this queue is empty. * * */ E poll(); /** * Retrieves, but does not remove, the head of this queue. This method * differs from &#123;@link #peek peek&#125; only in that it throws an exception * if this queue is empty. * */ E element(); /** * Retrieves, but does not remove, the head of this queue, * or returns &#123;@code null&#125; if this queue is empty. * */ E peek();&#125;]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java事务那点儿事儿]]></title>
    <url>%2F2018%2F07%2F04%2FJava%E4%BA%8B%E5%8A%A1%E9%82%A3%E7%82%B9%E5%84%BF%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[事务的定义事务是指访问并可能更新数据库中各种数据项的一个程序操作单元。 作为一个java web开发者，最早我们入门的时候应该都接触过jdbc事务： 123456789101112131415161718Connection connection = null; PreparedStatement preparedStatement = null; Class.forName("com.mysql.jdbc.Driver"); try &#123; connection = DriverManager.getConnection("jdbc:mysql://localhost/test"); connection.setAutoCommit(false); preparedStatement = connection.prepareStatement("INSERT UserInfo (username,age) VALUES (?,?)"); preparedStatement.setString(1,"Tom"); preparedStatement.setInt(2, 23); preparedStatement.execute(); connection.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); connection.rollback(); &#125;finally &#123; if (preparedStatement !=null) preparedStatement.close(); if (connection != null) connection.close(); &#125; java大致有三种事务模型，大致分为本地事务模型、编程式事务模型、声明式事务模型。 本地事务模型（Local Transaction Model）本地事务模型，是通过本地资源器（Local Resource Manager）来管理事务，而不依赖于编程框架。资源管理器是用于通信的实际的数据提供者，比如我们常用的jdbc访问数据库：其资源管理器是由数据库驱动和数据库管理系统共同来实现的。对于JMS来说，资源管理器是建立topic和queue的连接工厂。所以使用的本地事务管理模型，开发人员管理是连接而不是事务。实际的事务是由JMS和数据库管理系统的提供者来管理。 编程式事务模型（Programmatic Transaction Model）相对于本地事务模型，编程式事务模型利用JTA(Java Transaction API)以及底层的事务服务实现来提供事务的支持，更加灵活，突破种种限制。此时开发人员编程的对象是事务而不是连接了，通过javax.transaction.UserTransaction接口，调用begin()方法开始一个事务，通过commit()或rollback()方法终止这个事务。使用编程式事务模型固然很灵活，但一旦业务逻辑变得复杂管理起来便如噩梦一般，而且容易出错。但有些场景还是很有用的。 1、因为事务是非常消耗资源的，为了优化性能，有时候我们希望将一些无关的耗时较长的数据加载、校验等逻辑从事务范围内剥离出来，从而降低事务执行带来的资源消耗。2、当一个业务可能需要多次远程调用才能完成，按道理应该由客户端来开启事务，此时使用jta时，就需要使用UserTransaction接口和编程式事务，远程调用的方法使用声明式事务。 声明式事务模型（Declarative Transaction Model）声明式事务模型，使用编程框架或容器帮助完成了事务的开启、提交、回滚，开发者只需要告诉何时出现何种异常是否需要回滚即可。 事务的ACID特性ACID即，原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。原子性，操作的一组数据集合要么全部成功要么全部失败；一致性，保证数据库数据时刻避免数据被置于不一致的状态；隔离性，各个独立事务之间交互程度，对于同一数据访问的未提交事务直接相互不受影响；持久性，事务提交后保证修改的数据能够永久保存。 JTA与JTS随着项目规模的逐渐壮大，像JDBC这样的本地事务很快暴露出他无法跨数据库进行事务管理的弊端，面对越来越多的分布式场景，此时JTA事务就应运而生。JTA（Java Transaction API）java事务API，是开发者针对事务进行编程管理的API，允许完成跨多个XA资源的分布式事务；JTS（Java Transaction Service）被开源或商业应用服务采用，实现了JTA的底层事务服务。JTA和JTS之间的关系跟JDBC与对应的底层数据库驱动类似。我们在使用编程式事务时，我们仅仅需要使用的唯一接口为javax.transaction.UserTransaction: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/** * The UserTransaction interface defines the methods that allow an * application to explicitly manage transaction boundaries. */public interface UserTransaction &#123; /** * Create a new transaction and associate it with the current thread. * * @exception NotSupportedException Thrown if the thread is already * associated with a transaction and the Transaction Manager * implementation does not support nested transactions. * * @exception SystemException Thrown if the transaction manager * encounters an unexpected error condition. * */ void begin() throws NotSupportedException, SystemException; /** * Complete the transaction associated with the current thread. When this * method completes, the thread is no longer associated with a transaction. * * @exception RollbackException Thrown to indicate that * the transaction has been rolled back rather than committed. * * @exception HeuristicMixedException Thrown to indicate that a heuristic * decision was made and that some relevant updates have been committed * while others have been rolled back. * * @exception HeuristicRollbackException Thrown to indicate that a * heuristic decision was made and that all relevant updates have been * rolled back. * * @exception SecurityException Thrown to indicate that the thread is * not allowed to commit the transaction. * * @exception IllegalStateException Thrown if the current thread is * not associated with a transaction. * * @exception SystemException Thrown if the transaction manager * encounters an unexpected error condition. */ void commit() throws RollbackException, HeuristicMixedException, HeuristicRollbackException, SecurityException, IllegalStateException, SystemException; /** * Roll back the transaction associated with the current thread. When this * method completes, the thread is no longer associated with a transaction. * * @exception SecurityException Thrown to indicate that the thread is * not allowed to roll back the transaction. * * @exception IllegalStateException Thrown if the current thread is * not associated with a transaction. * * @exception SystemException Thrown if the transaction manager * encounters an unexpected error condition. * */ void rollback() throws IllegalStateException, SecurityException, SystemException; /** * Modify the transaction associated with the current thread such that * the only possible outcome of the transaction is to roll back the * transaction. * * @exception IllegalStateException Thrown if the current thread is * not associated with a transaction. * * @exception SystemException Thrown if the transaction manager * encounters an unexpected error condition. * */ void setRollbackOnly() throws IllegalStateException, SystemException; /** * Obtain the status of the transaction associated with the current thread. * * @return The transaction status. If no transaction is associated with * the current thread, this method returns the Status.NoTransaction * value. * * @exception SystemException Thrown if the transaction manager * encounters an unexpected error condition. * */ int getStatus() throws SystemException; /** * Modify the timeout value that is associated with transactions started * by the current thread with the begin method. * * &lt;p&gt; If an application has not called this method, the transaction * service uses some default value for the transaction timeout. * * @param seconds The value of the timeout in seconds. If the value is zero, * the transaction service restores the default value. If the value * is negative a SystemException is thrown. * * @exception SystemException Thrown if the transaction manager * encounters an unexpected error condition. * */ void setTransactionTimeout(int seconds) throws SystemException;&#125; 我们如果暂时挂起或者恢复一个事务，此时可以使用TransactionManager:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162/** * The TransactionManager interface defines the methods that allow an * application server to manage transaction boundaries. */public interface TransactionManager &#123; /** * Create a new transaction and associate it with the current thread. * * @exception NotSupportedException Thrown if the thread is already * associated with a transaction and the Transaction Manager * implementation does not support nested transactions. * * @exception SystemException Thrown if the transaction manager * encounters an unexpected error condition. * */ public void begin() throws NotSupportedException, SystemException; /** * Complete the transaction associated with the current thread. When this * method completes, the thread is no longer associated with a transaction. * * @exception RollbackException Thrown to indicate that * the transaction has been rolled back rather than committed. * * @exception HeuristicMixedException Thrown to indicate that a heuristic * decision was made and that some relevant updates have been committed * while others have been rolled back. * * @exception HeuristicRollbackException Thrown to indicate that a * heuristic decision was made and that all relevant updates have been * rolled back. * * @exception SecurityException Thrown to indicate that the thread is * not allowed to commit the transaction. * * @exception IllegalStateException Thrown if the current thread is * not associated with a transaction. * * @exception SystemException Thrown if the transaction manager * encounters an unexpected error condition. * */ public void commit() throws RollbackException, HeuristicMixedException, HeuristicRollbackException, SecurityException, IllegalStateException, SystemException; /** * Obtain the status of the transaction associated with the current thread. * * @return The transaction status. If no transaction is associated with * the current thread, this method returns the Status.NoTransaction * value. * * @exception SystemException Thrown if the transaction manager * encounters an unexpected error condition. * */ public int getStatus() throws SystemException; /** * Get the transaction object that represents the transaction * context of the calling thread. * * @return the &lt;code&gt;Transaction&lt;/code&gt; object representing the * transaction associated with the calling thread. * * @exception SystemException Thrown if the transaction manager * encounters an unexpected error condition. * */ public Transaction getTransaction() throws SystemException; /** * Resume the transaction context association of the calling thread * with the transaction represented by the supplied Transaction object. * When this method returns, the calling thread is associated with the * transaction context specified. * * @param tobj The &lt;code&gt;Transaction&lt;/code&gt; object that represents the * transaction to be resumed. * * @exception InvalidTransactionException Thrown if the parameter * transaction object contains an invalid transaction. * * @exception IllegalStateException Thrown if the thread is already * associated with another transaction. * * @exception SystemException Thrown if the transaction manager * encounters an unexpected error condition. */ public void resume(Transaction tobj) throws InvalidTransactionException, IllegalStateException, SystemException; /** * Roll back the transaction associated with the current thread. When this * method completes, the thread is no longer associated with a * transaction. * * @exception SecurityException Thrown to indicate that the thread is * not allowed to roll back the transaction. * * @exception IllegalStateException Thrown if the current thread is * not associated with a transaction. * * @exception SystemException Thrown if the transaction manager * encounters an unexpected error condition. * */ public void rollback() throws IllegalStateException, SecurityException, SystemException; /** * Modify the transaction associated with the current thread such that * the only possible outcome of the transaction is to roll back the * transaction. * * @exception IllegalStateException Thrown if the current thread is * not associated with a transaction. * * @exception SystemException Thrown if the transaction manager * encounters an unexpected error condition. * */ public void setRollbackOnly() throws IllegalStateException, SystemException; /** * Modify the timeout value that is associated with transactions started * by the current thread with the begin method. * * &lt;p&gt; If an application has not called this method, the transaction * service uses some default value for the transaction timeout. * * @param seconds The value of the timeout in seconds. If the value is zero, * the transaction service restores the default value. If the value * is negative a SystemException is thrown. * * @exception SystemException Thrown if the transaction manager * encounters an unexpected error condition. * */ public void setTransactionTimeout(int seconds) throws SystemException; /** * Suspend the transaction currently associated with the calling * thread and return a Transaction object that represents the * transaction context being suspended. If the calling thread is * not associated with a transaction, the method returns a null * object reference. When this method returns, the calling thread * is not associated with a transaction. * * @return Transaction object representing the suspended transaction. * * @exception SystemException Thrown if the transaction manager * encounters an unexpected error condition. * */ public Transaction suspend() throws SystemException;&#125; 并不是使用UserTransaction或者TransactionManager就将JDBC这样的本地事务转换成JTA事务，JTA事务要求Connection、DataSource、Resource必须符合XA规范，并实现了XA规范的接口才能参与到JTA事务当中（目前主流的数据库都支持XA规范）；也即要想使用JTA事务，需要有一个实现了javax.sql.XAConnection、javax.sql.XADataSource、javax.transaction.xa.XAResource的JDBC驱动程序，XADataSource相当于XAConnection的对象工厂，使用JTA事务，必须使用XADataSource获取一个XAConnection对象作为XA连接。XA连接（javax.sql.XAConnection）与非XA连接（javax.sql.Connection）区别在于，XA连接可以参与JTA事务并不支持自动提交。 JTA事务优点很明显支持了分布式事务，缺点是实现复杂，JTA UserTransaction通常需要利用JDNI来获取，即需要同时使用JTA和JNDI 虽然JTA是java提供的一套支持分布式事务的API，但是不同的J2EE平台的实现也不一样所以使用起来也不方便。 因为JTA事务的复杂性，目前业界只要的分布式事务解决方案主要有异步消息确保型、TCC、最大努力通知等。 标准的分布式事务一个标准的分布式事务包括一个事务管理器和一个或多个资源管理器（资源管理器是任意的持久化数据存储），事务管理器承担着参与事务的成员之间的通信职责。 JTA 深度历险-原理与实现 https://www.ibm.com/developerworks/cn/java/j-lo-jta/]]></content>
      <categories>
        <category>编程</category>
      </categories>
      <tags>
        <tag>Transaction,事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[免费的https证书]]></title>
    <url>%2F2018%2F06%2F30%2F%E5%85%8D%E8%B4%B9%E7%9A%84https%E8%AF%81%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[从网景创建SSL协议到目前的TLS 3.0已经有24个年头了，随着互联网的迅猛发展，现在主流的公司也纷纷进行了全站https的改造。跟随这波热潮也尝试了下应用https/http2.0，这里介绍下如何使用Let’s Encrypt签发免费的证书。 生成Let’s Encrypt证书talk is cheap,show me code:123git clone https://github.com/letsencrypt/letsencryptcd letsencrypt./letsencrypt-auto certonly --standalone -d relottery.cn 命令执行完毕会出现提示：MPORTANT NOTES: Congratulations! Your certificate and chain have been saved at:/etc/letsencrypt/live/relottery.cn/fullchain.pemYour key file has been saved at:/etc/letsencrypt/live/relottery.cn/privkey.pemYour cert will expire on 2018-04-18. To obtain a new or tweakedversion of this certificate in the future, simply runletsencrypt-auto again. To non-interactively renew all of yourcertificates, run “letsencrypt-auto renew” 大功告成，在/etc/letsencrypt/live/relottery.cn/目录下会生成秘钥证书文件：1234cert.pem - Apache服务器端证书chain.pem - Apache根证书和中继证书fullchain.pem - Nginx所需要ssl_certificate文件privkey.pem - 安全证书KEY文件 这里我使用的nginx，所以我需要fullchain.pem和privkey.pem两个文件做如下配置：12ssl_certificate /etc/letsencrypt/live/relottery.cn/fullchain.pem;ssl_certificate_key /etc/letsencrypt/live/relottery.cn/privkey.pem; 细心的同学会发现，上面提示我们证书是存在有效期的(90天)，如果过期再手动去执行太蠢了，show the code： 1234crontab -e 30 2 * * 1 /home/app/letsencrypt/letsencrypt/letsencrypt-auto renew35 2 * * 1 /home/app/openresty/nginx/sbin/nginx -s reload done. 遇到的问题/home/app/letsencrypt/letsencrypt/letsencrypt-auto renewWARNING: unable to check for updates.Creating virtual environment…Installing Python packages…Had a problem while installing Python packages.pip prints the following errors: Collecting argparse==1.4.0 (from -r /tmp/tmp.Xf3AdlgJol/letsencrypt-auto-requirements.txt (line 11)) Downloading http://mirrors.aliyun.com/pypi/packages/f2/94/3af39d34be01a24a6e65433d19e107099374224905f1e0cc6bbe1fd22a2f/argparse-1.4.0-py2.py3-none-any.whl Downloading http://mirrors.aliyun.com/pypi/packages/fd/21/0c6f33829fadec8aca0c1ebb4d6f8101c05899356a58d1b2e506cb77cf18/letsencrypt-0.7.0-py2-none-any.whl Collecting certbot==0.21.0 (from -r /tmp/tmp.Xf3AdlgJol/letsencrypt-auto-requirements.txt (line 206)) Could not find a version that satisfies the requirement certbot==0.21.0 (from -r /tmp/tmp.Xf3AdlgJol/letsencrypt-auto-requirements.txt (line 206)) (from versions: 0.6.0, 0.7.0, 0.8.0, 0.8.1, 0.9.0, 0.9.1, 0.9.2, 0.9.3, 0.10.0, 0.10.1, 0.10.2, 0.11.0, 0.11.1, 0.12.0, 0.13.0, 0.14.0, 0.14.1, 0.14.2, 0.15.0, 0.16.0, 0.17.0, 0.18.0, 0.18.1, 0.18.2, 0.19.0, 0.20.0)No matching distribution found for certbot==0.21.0 (from -r /tmp/tmp.Xf3AdlgJol/letsencrypt-auto-requirements.txt (line 206)) Certbot has problem setting up the virtual environment.We were not be able to guess the right solution from your pipoutput.Consult https://certbot.eff.org/docs/install.html#problems-with-python-virtual-environmentfor possible solutions.You may also find some support resources at https://certbot.eff.org/support/ . 本来挺信任阿里云的pip源的 哎 果断换之：~/.pip/pip.conf1234[global]index-url=https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host=pypi.tuna.tsinghua.edu.cn 国内的pip镜像阿里云 http://mirrors.aliyun.com/pypi/simple/中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/豆瓣(douban) http://pypi.douban.com/simple/清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/]]></content>
      <categories>
        <category>计算机网络</category>
      </categories>
      <tags>
        <tag>https</tag>
      </tags>
  </entry>
</search>
