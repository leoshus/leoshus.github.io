<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[告别2019展望2020]]></title>
    <url>%2Flife%2F%E5%91%8A%E5%88%AB2019%E5%B1%95%E6%9C%9B2020%2F</url>
    <content type="text"><![CDATA[从18年开始就想写下年度总结，一直拖动19年，然而还是在2020年的开端提起了锈迹斑斑的笔… … 惭愧 回望18年&nbsp;&nbsp;生活上完成了两件大事儿： 1. 完成了北漂着陆 有了一个自己的小窝 走上了负翁的道路 2. 找到了我的开瓶盖儿 结束了单身生涯 &nbsp;&nbsp;工作上，从16年11月开始由自己完全负责的公司内部孵化的APP也平稳走上正轨，完成了盈利。从15年2月加入网易到16年自己负责一个产品的整体技术，并顺利推进上线完成盈利。感谢公司领导的信任、同事的支持，感谢自己这几年的努力总算没有白费。但是产品的发展跟我的期许有了比较大的分歧，内部产品规划缺乏主线，外部产品业务严重受政策制约。也是因为是一个比较垂直的行业，尽管能够盈利，但用户规模一直上不去。另一方面我觉得目前产品规划不够大胆，自己可能也想出去再看看，慢慢有了跑路的想法，于是9月份的时候出去看了一圈，也拿了几个offer，不过最终没敌过金钱的诱惑（想想负债 忍了 现在回想起来有些后悔），最终未能成行整个18年 感觉自己收获了很多，但是做决定还是不够决断。 回望19年整个19年感觉自己慢慢走进了舒适区，慢慢走上管理岗位，感觉每天都是在开会中度过，想有段完整的时间 好好写段代码都是奢侈。以至于感觉每天上班都是煎熬，感觉技术基本都在原地踏步走 而且产品业务也是不愠不火 整个上半年整个人都觉得是在温水煮青蛙，下半年终于痛下决心，出来溜达溜达，最终选择了一家创业公司，比较看好当前的业务发展前景，也拿了一些期权，感觉自己现在还年轻，趁年轻，搏一搏 至于成功与否 谁知道呢 也许自己真的不想过着一眼能遇见到头的工作。好了 单行好事 莫问前程 希望2020自己再努力拼搏一下 找找不一样的变化 不管好坏 也对得起自己的青春了。 展望2020希望2020自己的拼搏付出能有所收获，然后立下flag吧： 坚持blog 坚持技术 人文社科书籍的阅读 坚持锻炼 调整生活作息 争取练出腹肌]]></content>
      <categories>
        <category>life</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[并发笔记之CountDownLatch分析]]></title>
    <url>%2FJava%E5%B9%B6%E5%8F%91%2F%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B9%8BCountDownLatch%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[CountDownLatch也是同步的辅助工具，它允许一个或多个线程等待直到在其他线程中完成一组操作。CountDownLatch由一个给定的count值初始化，其await()操作会一直等待直到countDown()操作将count值递减为0为止，然后会释放所有阻塞的线程(即await后的所有操作都会立即返回)。但相比CyclicBarrier这个操作只能执行一次，count不会被重置。 主要属性1234567891011121314151617181920212223242526272829303132333435363738394041public class CountDownLatch &#123; /** * Synchronization control For CountDownLatch. * Uses AQS state to represent count. */ private static final class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = 4982264981922014374L; Sync(int count) &#123; setState(count); &#125; int getCount() &#123; return getState(); &#125; //获取同步状态 protected int tryAcquireShared(int acquires) &#123; return (getState() == 0) ? 1 : -1; &#125; //释放同步状态 protected boolean tryReleaseShared(int releases) &#123; // Decrement count; signal when transition to zero for (;;) &#123; int c = getState(); if (c == 0) return false; int nextc = c-1; if (compareAndSetState(c, nextc)) return nextc == 0; &#125; &#125; &#125; private final Sync sync; public CountDownLatch(int count) &#123; if (count &lt; 0) throw new IllegalArgumentException("count &lt; 0"); this.sync = new Sync(count); &#125; ... ... &#125; 可以看出CountDownLatch内部依赖Sync实现，而Sync继承了AQS。tryAcquireShared和tryReleaseShared两个方法的重写，可得出其是利用共享锁来实现的。 等待await()1234567 public void await() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1);&#125;public boolean await(long timeout, TimeUnit unit) throws InterruptedException &#123; return sync.tryAcquireSharedNanos(1, unit.toNanos(timeout));&#125; 没啥好说的利用同步锁的机制实现 countDown()1234567891011121314public void countDown() &#123; sync.releaseShared(1);&#125;protected boolean tryReleaseShared(int releases) &#123; // Decrement count; signal when transition to zero for (;;) &#123; int c = getState(); if (c == 0) return false; int nextc = c-1; if (compareAndSetState(c, nextc)) return nextc == 0; &#125;&#125; 通过递减count值 将其递减为0，使得tryAcquireShared中(getState() == 0) ? 1 : -1返回为1 从而从阻塞中退出12345678910111213141516171819202122232425private void doAcquireSharedInterruptibly(int arg) throws InterruptedException &#123; final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123;//退出自旋 setHeadAndPropagate(node, r); p.next = null; // help GC failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125;]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发笔记之CAS分析]]></title>
    <url>%2FJava%E5%B9%B6%E5%8F%91%2F%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B9%8BCAS%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[CAS,Compare And Swap,即比较并交换。整个AQS同步组件、Atomic原子类操作等等都是以CAS实现的，甚至ConcurrentHashMap在1.8版本也调整为了CAS+synchronized。Lock/synchronized是一种悲观锁，但大多数情况并没有大量的竞争，相对而言CAS是一种乐观锁策略，认为竞争很少发生，一旦发生则抛给处理方处理重试还是采取其他策略，由于没有加锁带来的较高开销和加锁中的临界区限制，这种无锁机制比加锁具有更高的扩展性。 底层原理CAS的思想很简单，有三个参数：内存值V、旧值A、要更新的值B。当且仅当内存值V等于旧的预期值A时才会将内存值V更新为B，否则什么都不干。JUC下的atomic类是通过CAS来实现的，以AtomicInteger为例：12345678910111213141516171819public class AtomicInteger extends Number implements java.io.Serializable &#123; private static final long serialVersionUID = 6214790243416807050L; // setup to use Unsafe.compareAndSwapInt for updates private static final Unsafe unsafe = Unsafe.getUnsafe(); private static final long valueOffset; static &#123; try &#123; valueOffset = unsafe.objectFieldOffset (AtomicInteger.class.getDeclaredField("value")); &#125; catch (Exception ex) &#123; throw new Error(ex); &#125; &#125; //使用volatile修饰保证修改 其他线程的可见性 private volatile int value; public final int getAndIncrement() &#123; return unsafe.getAndAddInt(this, valueOffset, 1); &#125;sun.misc.Unsafe是CAS的核心类，Java无法直接访问操作系统底层，通过Unsafe可以在内存级别获取操作对象内存中的数据。unsafe.getAndAddInt实现了原子增的操作12345678910public final int getAndAddInt(Object o, long offset, int delta) &#123; int v; do &#123; v = getIntVolatile(o, offset); &#125; while (!compareAndSwapInt(o, offset, v, v + delta)); return v;&#125;public final native boolean compareAndSwapInt(Object o, long offset, int expected, int x);可以看到最终通过JNI完成本地调用来实现，看下openJDK实现unsafe.cpp：++123456789101112131415161718192021222324252627UNSAFE_ENTRY(jboolean, Unsafe_CompareAndSwapInt(JNIEnv *env, jobject unsafe, jobject obj, jlong offset, jint e, jint x)) UnsafeWrapper("Unsafe_CompareAndSwapInt"); oop p = JNIHandles::resolve(obj); jint* addr = (jint *) index_oop_from_field_offset_long(p, offset); return (jint)(Atomic::cmpxchg(x, addr, e)) == e;UNSAFE_END//atomic.cppjbyte Atomic::cmpxchg(jbyte exchange_value, volatile jbyte* dest, jbyte compare_value) &#123; assert(sizeof(jbyte) == 1, "assumption."); uintptr_t dest_addr = (uintptr_t)dest; uintptr_t offset = dest_addr % sizeof(jint); volatile jint* dest_int = (volatile jint*)(dest_addr - offset); jint cur = *dest_int; jbyte* cur_as_bytes = (jbyte*)(&amp;cur); jint new_val = cur; jbyte* new_val_as_bytes = (jbyte*)(&amp;new_val); new_val_as_bytes[offset] = exchange_value; while (cur_as_bytes[offset] == compare_value) &#123; jint res = cmpxchg(new_val, dest_int, cur); if (res == cur) break; cur = res; new_val = cur; new_val_as_bytes[offset] = exchange_value; &#125; return cur_as_bytes[offset];&#125;以linux x86为例，MP表示multiprocessor即多处理器。最终根据具体的处理器架构转换成汇编指令来实现CAS.atomic_linux_x86.inline.hpp:++12345678inline jint Atomic::cmpxchg (jint exchange_value, volatile jint* dest, jint compare_value) &#123; int mp = os::is_MP(); __asm__ volatile (LOCK_IF_MP(%4) "cmpxchgl %1,(%3)" : "=a" (exchange_value) : "r" (exchange_value), "a" (compare_value), "r" (dest), "r" (mp) : "cc", "memory"); return exchange_value;&#125;这里的cmpxchg是x86和Intel架构中的compare and exchange指令。__asm__说明是ASM汇编，__volatile__禁止编译器优化当多处理时需要前面加上lock指令。12// Adding a lock prefix to an instruction on MP machine#define LOCK_IF_MP(mp) "cmp $0, " #mp "; je 1f; lock; 1: "os::is_MP()判断当前系统是否为多核系统，如果是就给总线加锁，故同一芯片上的其他处理器就暂时不能通过总线访问内存，保证了该指令在多处理器环境下的原子性。 CAS的问题ABA问题CAS需要在操作值的时候检查下值有没有发生变化，如果没有发生变化则更新，但是如果一个值从A变为B，又从B变成A，那么CAS在进行检查的时候会发现它的值没有发生变化，但实际发生了改变，这就是ABA问题。解决思路：为变量加上版本号，每次修改版本号加一，目前JDK的atomic包里提供了AtomicStampedReference来解决ABA问题。这个类会检查当前引用是否等于预期的引用，并且当前的标识是否等于预期标识，如果全部相等，则以原子的方式将该引用和该标识进行更新。 自旋时间过长如果CAS一直不成功，则一直自旋 对CPU将带来极大的开销。]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发笔记之volatile实现原理]]></title>
    <url>%2FJava%E5%B9%B6%E5%8F%91%2F%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B9%8Bvolatile%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[volatile是轻量级的synchronized，理解volatile特性的一个好办法就是把对volatile变量的读/写，看成是使用同一把锁对这些单个读/写操作做同步。 Java语言规范对volatile的定义如下： Java编程语言允许线程访问共享变量，为了确保共享变量能被准确和一致的更新，线程应该确保通过排他锁单独获得这个变量。 通俗点讲就是一个变量如果被volatile修饰了，则Java可以确保所有线程看到这个变量是一致的，如果某个线程对volatile修饰的变量做修改，那么其他线程就可以立马看到这个更新，也就是所谓的线程可见性 操作系统语义计算机运行程序时，每条指令都在CPU中执行，执行过程中势必也会读写数据。程序的数据存储在主存中，现代计算机发展到目前 主存的读写速度和CPU的计算速度仍然存在巨大的差距，所以就有了高速缓存(L1/L2/L3)。CPU高速缓存为某个CPU独有，只与该CPU运行的线程有关。CPU的高速缓存解决了效率问题，但带来的新的问题：数据一致性问题在程序运行时会将数据复制一份到高速缓存中，CPU计算时直接从高速缓存中读写，只有运行结束后才会将数据刷新到主存中。解决缓存一致性方案有两种： 在地址总线加LOCK#锁 缓存一致性协议(MESI协议) 方案一采用一种独占的方式来实现，即总线加LOCK#锁，则同时只有一个CPU能够操作，效率较为低下方案二缓存一致性协议(MESI协议)它确保每个缓存中使用的共享变量的副本是一致的。其核心思想：当某个CPU在写数据时，如果发现操作的变量是共享变量，则会通知其他CPU告知改变量的缓存行是无效的，因此其他CPU在读取该变量时发现其无效会重新从主存中加载数据。 地址总线加LOCK#锁如果多个处理器同时对同一共享变量进行 decl指令操作，那这个操作一定不是原子的，也就是执行的结果和预期结果不一致。如下图所示，我们期望的结果是3，但是有可能结果是2如果要解决这个问题，就需要是的CPU0在更新共享变量时，CPU1就不能操作缓存了该共享变量内存地址的缓存，所以处理器提供了总线锁来解决问题，处理器会提供一个LOCK#信号，当一个处理器在总线上输出这个信号时，其他处理器的请求会被阻塞，那么该处理器就可以独占共享内存总线锁有一个弊端，总线锁相当于使得多个CPU由并行执行变成了串行，使得CPU的性能严重下降，所以在P6系列以后的处理器中，引入了缓存锁。 缓存一致性协议(MESI协议)我们只需要保证 多个线程操作同一个被缓存的共享数据的原子性就行，所以只需要锁定被缓存的共享对象即可。所谓缓存锁是指被缓存在处理器中的共享数据，在Lock操作期间被锁定，那么当被修改的共享内存的数据回写到内存时，处理器不在总线上声明LOCK#信号，而是修改内部的内存地址，并通过 缓存一致性机制来保证操作的原子性。缓存一致性所谓缓存一致性，就是多个CPU核心中缓存的同一共享数据的数据一致性，而(MESI)使用比较广泛的缓存一致性协议。MESI协议实际上是表示缓存的四种状态M(Modify) 表示共享数据只缓存在当前CPU缓存中，并且是被修改状态，也就是缓存的数据和主内存中的数据不一致E(Exclusive) 表示缓存的独占状态，数据只缓存在当前CPU缓存中，并且没有被修改S(Shared) 表示数据可能被多个CPU缓存，并且各个缓存中的数据和主内存数据一致I(Invalid) 表示缓存已经失效每个CPU核心不仅仅知道自己的读写操作，也会监听其他Cache的读写操作 CPU的读取会遵循几个原则如果缓存的状态是I，那么就从内存中读取，否则直接从缓存读取如果缓存处于M或者E的CPU 嗅探到其他CPU有读的操作，就把自己的缓存写入到内存，并把自己的状态设置为S只有缓存状态是M或E的时候，CPU才可以修改缓存中的数据，修改后，缓存状态变为M Java内存模型原子性即一个操作或者多个操作 要么全部成功要么全部失败单线程环境下，我们可以认为整个步骤都是原子操作，但在多线程环境下则不同，Java只保证了基本数据类型的变量和赋值操作才是原子性的 多线程下原子性则需要锁、synchronized来保证。volatile无法保证复合操作的原子性 可见性即多个线程访问同一变量时，一个线程修改了这个变量的值 其他线程能够立刻看到修改的值。volatile写操作语义： 修改volatile变量时会强制将修改后的值刷新到主内存中 修改volatile变量后会导致其他线程工作内存中对应的变量值失效，故再读取该变量值时就需要重新从主存中读取 有序性即程序执行的顺序按照代码的先后顺序执行。在Java内存模型中，为了效率是允许编译器和处理器对指令进行重排序，当然重排序不会影响单线程的运行结果，但是对多线程会有影响。Java提供volatile来保证一定的有序性。 ####从JMM层面解决线程并发问题JMM属于语言级别的抽象内存模型，可以简单理解为对硬件模型的抽象，它定义了共享内存中多线程程序读写操作的行为规范，也就是在虚拟机中将共享变量存储到内存以及从内存中取出共享变量的底层细节。 通过这些规则来规范对内存的读写操作从而保证指令的正确性，它解决了CPU多级缓存、处理器优化、指令重排序导致的内存访问问题，保证了并发场景下的可见性。 需要注意的是，JMM并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序，也就是说在JMM中，也会存在缓存一致性问题和指令重排序问题。只是JMM把底层的问题抽象到JVM层面，再基于CPU层面提供的内存屏障指令，以及限制编译器的重排序来解决并发问题Java内存模型定义了线程和内存的交互方式，在JMM抽象模型中，分为主内存、工作内存；主内存是所有线程共享的，一般是实例对象、静态字段、数组对象等存储在堆内存中的变量。工作内存是每个线程独占的，线程对变量的所有操作都必须在工作内存中进行，不能直接读写主内存中的变量，线程之间的共享变量值的传递都是基于主内存来完成。 在JMM中，定义了8个原子操作来实现一个共享变量如何从主内存拷贝到工作内存，以及如何从工作内存同步到主内存8个原子操作指令lock(锁定)：作用于主内存的变量，把一个变量标识为一条线程独占状态。unlock(解锁)：作用于主内存变量，把一个处于锁定状态的变量释放出来，释放后的变量才可以被其他线程锁定。read(读取)：作用于主内存变量，把一个变量值从主内存传输到线程的工作内存中，以便随后的load动作使用load(载入)：作用于工作内存的变量，它把read操作从主内存中得到的变量值放入工作内存的变量副本中。use(使用)：作用于工作内存的变量，把工作内存中的一个变量值传递给执行引擎，每当虚拟机遇到一个需要使用变量的值的字节码指令时将会执行这个操作。assign(赋值)：作用于工作内存的变量，它把一个从执行引擎接收到的值赋值给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。store(存储)：作用于工作内存的变量，把工作内存中的一个变量的值传送到主内存中，以便随后的write的操作。write(写入)：作用于主内存的变量，它把store操作从工作内存中一个变量的值传送到主内存的变量中。 volatile原理volatile可以保证线程可见性且提供了一定的有序性，但无法保证原子性。 观察加入volatile关键字和没有加入volatile关键字时所生成的汇编代码会发现，加入volatile关键字时，会多出一个lock前缀指令 lock前缀指令实际上相当于一个内存屏障（也称内存栅栏，是一组处理器指令，用于实现对内存操作的顺序限制），内存屏障会提供3个功能： 它确保指令重排序时不会把其后面的指令重排序到内存屏障之前，也不会把前面的指令排到内存屏障的后面；即执行到内存屏障指令时其前面的操作都已经全部完成 它会强制将对缓存的修改操作立即写入主存 如果是写操作 他会导致其他CPU的对应缓存行无效 在JVM底层volatile是采用内存屏障来实现，即： 保证可见性 但不保证原子性 禁止指令重排序 指令重排序在执行程序时为了提供性能，编译器和处理器通常会对指令做重排序： 编译器重排序 编译器在不改变单线程语义的前提下，可以重新安排语句的执行顺序 处理器重排序 如果不存在数据依赖性，处理器可以改变语句对应机器指令的执行顺序 指令重排序对单线程没有影响，但是会影响多线程的正确性。故对多线程我们需要禁止指令重排序 happens-before原则Java内存模型中具备一些先天的“有序性”，即不需要通过任何手段就能保证有序性，这个通常被称为happens-before(先行发生原则)。如果两个操作的执行顺序无法通过happens-before原则推导出来，那么它们就不能保证他们的有序性，虚拟机就可以随意地对他们进行重排序。下面介绍下happens-before原则： 程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作 锁定规则：一个unlock操作先行发生于后面对同一个锁的lock操作 volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作 传递规则： 如果操作A先行发生于B，而操作B又先行发生于C，则可得出操作A先行发生于C 线程启动规则：Thread对象的start()方法先行发生于此线程的每一个动作 线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程检测到中断事件的发生 线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行 对象终结规则：一个对象的初始化先行发生于他的finalize()方法的开始 volatile写-读建立的happens-before关系从内存语义的角度来说，volatile的写-读与锁的释放-获取具有相同的内存效果： volatile的写和锁的释放有相同的内存语义 volatile的读和锁的获取有相同的内存语义 12345678910111213141516class VolatileExample&#123; int a = 0; volatile boolean flag = false; public void writer()&#123; a = 1; //1 flag = true;//2 &#125; public void reader()&#123; if(flag)&#123; //3 int i = a;//4 ... ... &#125; &#125;&#125; 假设线程A执行writer()方法之后，线程B执行reader()方法。根据happens-before原则，这个过程建立的happens before关系可以分成两类： 根据程序次序规则，1 happens before 2; 3 happens before 4 根据volatile规则， 2 happends before 3 根据happens-before的传递性规则，1 happens before 4 volatile 写-读的内存语义 volatile写的内存语义：当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量值刷新到主内存 volatile读的内存语义：当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效。线程接下来将从主内存中读取共享变量。 总结一下volatile写和volatile读的内存语义： 线程A写一个volatile变量，实质上是线程A向接下来将要读取这个volatile变量的某个线程发出了（其对共享变量所在修改的）消息 线程B读一个volatile变量，实质上是线程B接收到之前某个线程发出的（在写这个volatile变量之前对共享变量所在修改的）消息 线程A写一个volatile变量，随后线程B读这个volatile变量，这个过程实质上是线程A通过主内存向线程B发送消息 volatile内存语义的实现前面提到过重排序分为编译器重排序和处理器重排序。为了实现volatile内存语义，JMM会分别限制这两种类型的重排序类型。下面是针对编译器制定的volatile重排序规则表： 是否能重排序 第二个操作 第一个操作 普通读/写 volatile读 volatile写 普通读/写 NO volatile读 NO NO NO volatile写 NO NO 从上表可以看出： 当第二个操作是volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后 当第一个操作是volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作都不会被编译器重排序到volatile读之前 当第一个操作是volatile写，第二个操作是volatile读时，不能重排序 为了实现volatile的内存语义，编译器在生成字节码时，会在指令序列中插入内存屏障来禁止特定类型的处理器重排序。对于编译器来说，发现一个最优布置来最小化插入屏障的总数几乎不可能，为此，JMM采取保守策略。下面是基于保守策略的JMM内存屏障插入策略： 在每个volatile写操作的前面插入一个StoreStore屏障 在每个volatile写操作的后面插入一个StoreLoad屏障 在每个volatile读操作的后面插入一个LoadLoad屏障 在每个volatile读操作的后面插入一个LoadStore屏障 保守策略下 volatile写插入内存屏障后生成的指令序列示意图： 保守策略下 volatile读插入内存屏障后生成的指令序列示意图： JVM层面的内存屏障 屏障类型 指令示例 备注 LoadLoad Barriers load1;LoadLoad;load2 确保load1数据的装载优先于load2及后续装载指令的装载 StoreStore Barriers store1;StoreStore;store2 确保store1数据对其他处理器可见优先于store2及所有后续存储指令的存储 LoadStore Barriers load1;LoadStore;store2 确保load1数据装载优先于store2以及后续的存储指令刷新到内存 StoreLoad Barriers store1;StoreLoad;load2 确保store1数据对其他处理器变得可见优先于load2及所有后续装载指令的装载，这条内存屏障指令是一个全能型的屏障 总结volatile是并发编程中的一种优化，某些场景下可以代替synchronized，但volatile并不能完全取代synchronized，使用volatile总的来说，必须同时满足下面两个条件才能保证在并发环境的线程安全： 对变量的写操作不依赖于当前值 该变量没有包含在具有其他变量的不变式中 Volatile的作用及原理]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[并发笔记之重入锁ReentrantLock分析]]></title>
    <url>%2FJava%E5%B9%B6%E5%8F%91%2F%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B9%8B%E9%87%8D%E5%85%A5%E9%94%81ReentrantLock%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[ReentrantLock可重入锁，是一种递归无阻塞的同步机制，可等同于synchronized但比synchronized更加强大、灵活。 ReentrantLock提供了公平锁和非公平锁，构造方法接受一个可选参数(默认为非公平锁)，非公平锁往往会比公平锁效率更高 公平锁：加锁前会检查同步队列中是否有等待线程，优先排队等待的线程，先来先执行 非公平锁：加锁时不考虑排队问题，直接尝试获取锁，获取不到就自动追加到同步队列尾部 非公平锁1234567891011121314151617181920212223242526272829303132333435363738static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = 7316153563782823691L; /** * Performs lock. Try immediate barge, backing up to normal * acquire on failure. */ final void lock() &#123; if (compareAndSetState(0, 1)) setExclusiveOwnerThread(Thread.currentThread()); else acquire(1); &#125; protected final boolean tryAcquire(int acquires) &#123; return nonfairTryAcquire(acquires); &#125;&#125;final boolean nonfairTryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) // overflow throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false;&#125; 公平锁1234567891011121314151617181920212223242526272829303132static final class FairSync extends Sync &#123; private static final long serialVersionUID = -3000897897090466540L; final void lock() &#123; acquire(1); &#125; /** * Fair version of tryAcquire. Don't grant access unless * recursive call or no waiters or is first. */ protected final boolean tryAcquire(int acquires) &#123; final Thread current = Thread.currentThread(); int c = getState(); if (c == 0) &#123; if (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(0, acquires)) &#123; setExclusiveOwnerThread(current); return true; &#125; &#125; else if (current == getExclusiveOwnerThread()) &#123; int nextc = c + acquires; if (nextc &lt; 0) throw new Error("Maximum lock count exceeded"); setState(nextc); return true; &#125; return false; &#125;&#125; 公平锁模式在获取同步状态前先通过调用hasQueuedPredecessors()方法判断同步队列中是否存在等待执行的线程，如果有则优先执行12345678910public final boolean hasQueuedPredecessors() &#123; // The correctness of this depends on head being initialized // before tail and on head.next being accurate if the current // thread is first in queue. Node t = tail; // Read fields in reverse initialization order Node h = head; Node s; return h != t &amp;&amp; ((s = h.next) == null || s.thread != Thread.currentThread());&#125; 释放锁12345678910111213141516171819202122232425public void unlock() &#123; sync.release(1);&#125;public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125;protected final boolean tryRelease(int releases) &#123; int c = getState() - releases; if (Thread.currentThread() != getExclusiveOwnerThread()) throw new IllegalMonitorStateException(); boolean free = false; if (c == 0) &#123; free = true; setExclusiveOwnerThread(null); &#125; setState(c); return free;&#125; ConditionLock提供了条件Condition，对线程的等待、唤醒操作更加灵活、详细。12345678910111213141516171819202122232425262728293031323334353637383940public interface Condition &#123; /** * 造成当前线程在接到信号或中断前一直处于等待状态 */ void await() throws InterruptedException; /** * 造成当前线程在接到信号前一直处于等待状态 */ void awaitUninterruptibly(); /** * 造成当前线程等待直到收到信号、被中断或到达指定等待时间 * 返回值表示剩余时间，若nanosTimeout前唤醒则返回值=nanosTimeout-消耗时间 * 若返回值&lt;=0则可以认定它已经超时 */ long awaitNanos(long nanosTimeout) throws InterruptedException; /** * 造成当前线程等待直到收到信号、被中断或到达指定等待时间 */ boolean await(long time, TimeUnit unit) throws InterruptedException; /** * 造成当前线程等待直到它收到信号、被中断或等待超时 * 若未到指定时间返回true 否则返回false */ boolean awaitUntil(Date deadline) throws InterruptedException; /** * 唤醒一个等待线程 */ void signal(); /** * 唤醒所有等待线程 */ void signalAll();&#125; Condition的实现获取一个Condition必须要通过Lock的newCondition()方法。该方法定义在接口Lock中，返回值是绑定此Lock实例的新的Condition实例。Condition接口只有一个实现类ConditionObject。12345678public class ConditionObject implements Condition, java.io.Serializable &#123; private static final long serialVersionUID = 1173984872572414699L; /** 条件队列第一个节点 */ private transient Node firstWaiter; /** 条件队列最后一个节点*/ private transient Node lastWaiter; ... ...&#125; await等待当调用await()方法，当前线程会进入等待状态，并将把当前线程构造成一个节点(Node)并加入到条件队列的尾部，同时释放锁 如下图： Condition的条件队列相对CLH同步队列较简单，只需要将原尾节点的nextWaiter指向新节点 然后更新lastWaiter即可123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687public final void await() throws InterruptedException &#123; if (Thread.interrupted())//当前线程被中断 throw new InterruptedException(); Node node = addConditionWaiter();//将当前线程加入到Condition等待队列 int savedState = fullyRelease(node);//释放锁 int interruptMode = 0; while (!isOnSyncQueue(node)) &#123; //如果节点不在同步队列里 则挂起当前线程 LockSupport.park(this); if ((interruptMode = checkInterruptWhileWaiting(node)) != 0)//如果当前线程被中断 则退出 break; &#125; //尝试获得锁 if (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE) interruptMode = REINTERRUPT; if (node.nextWaiter != null) // 清理取消的节点 unlinkCancelledWaiters(); if (interruptMode != 0) reportInterruptAfterWait(interruptMode);&#125;//将当前线程构造成Node 加入到Condition的等待队列中private Node addConditionWaiter() &#123; Node t = lastWaiter; // If lastWaiter is cancelled, clean out. if (t != null &amp;&amp; t.waitStatus != Node.CONDITION) &#123; unlinkCancelledWaiters(); t = lastWaiter; &#125; Node node = new Node(Thread.currentThread(), Node.CONDITION); if (t == null) firstWaiter = node; else t.nextWaiter = node; lastWaiter = node; return node;&#125;//清理非CONDITION状态的节点private void unlinkCancelledWaiters() &#123; Node t = firstWaiter; Node trail = null; while (t != null) &#123; Node next = t.nextWaiter; if (t.waitStatus != Node.CONDITION) &#123; t.nextWaiter = null; if (trail == null) firstWaiter = next; else trail.nextWaiter = next; if (next == null) lastWaiter = trail; &#125; else trail = t; t = next; &#125;&#125;//释放当前锁 如果失败则将当前节点状态更新为取消CANCELLEDfinal int fullyRelease(Node node) &#123; boolean failed = true; try &#123; int savedState = getState(); if (release(savedState)) &#123; failed = false; return savedState; &#125; else &#123; throw new IllegalMonitorStateException(); &#125; &#125; finally &#123; if (failed) node.waitStatus = Node.CANCELLED; &#125;&#125;//检查节点是否在同步队列上final boolean isOnSyncQueue(Node node) &#123; if (node.waitStatus == Node.CONDITION || node.prev == null) return false; if (node.next != null) // If has successor, it must be on queue return true; /* * node.prev can be non-null, but not yet on queue because * the CAS to place it on queue can fail. So we have to * traverse from tail to make sure it actually made it. It * will always be near the tail in calls to this method, and * unless the CAS failed (which is unlikely), it will be * there, so we hardly ever traverse much. */ return findNodeFromTail(node);&#125; signal通知调用Condition的signal()方法，将唤醒在Condition等待队列等待最长时间的节点(即条件队列的首节点)，在唤醒节点前会将节点移到CLH同步队列中。1234567public final void signal() &#123; if (!isHeldExclusively())//当前节点是否获得了锁 throw new IllegalMonitorStateException(); Node first = firstWaiter; if (first != null) doSignal(first);&#125;signal()首先判断当前线程是否获得了锁，然后唤醒条件队列的首节点12345678private void doSignal(Node first) &#123; do &#123; if ( (firstWaiter = first.nextWaiter) == null) lastWaiter = null; first.nextWaiter = null; &#125; while (!transferForSignal(first) &amp;&amp; (first = firstWaiter) != null);&#125;doSignal()主要做了两件事： 修改条件队列的首节点 调用transferForSignal()将首节点移到CLH同步队列 12345678910111213final boolean transferForSignal(Node node) &#123; /* * If cannot change waitStatus, the node has been cancelled. */ if (!compareAndSetWaitStatus(node, Node.CONDITION, 0)) return false; Node p = enq(node);//将当前节点加入到CLH同步队列 成功则返回当前节点的前继节点 int ws = p.waitStatus; //如果当前节点的前继节点取消 或更新waitStatus失败则直接唤醒当前线程 if (ws &gt; 0 || !compareAndSetWaitStatus(p, ws, Node.SIGNAL)) LockSupport.unpark(node.thread); return true;&#125; 总结一个线程获取到锁之后，通过调用Condition的await()方法，会将当前线程加入到条件队列，然后释放锁 之后通过isOnSyncQueue(Node node)方法不断自查节点是否已经在CLH同步队列中。如果是则尝试获取锁 否则一直挂起。当线程调用signal()方法，程序首先检查当前线程是否获得了锁，然后通过doSignal()方法唤醒CLH同步队列的首节点。被唤醒的线程，将从await()方法中的while循环中退出来，然后调用acquireQueued()方法竞争同步状态。]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发笔记之AQS原理分析]]></title>
    <url>%2FJava%E5%B9%B6%E5%8F%91%2F%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B9%8BAQS%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[AQS、AbstractQueuedSynchronizer，即队列同步器。他是构建其他同步组件的基础框架，如ReentrantLock、ReentrantReadWriteLock、Semaphore、CountDownLatch等。 概述AQS使用一个int类型的成员变量state来表示同步状态，当state&gt;0表示获得了锁，当state=0表示释放了锁。内置的FIFO同步队列来完成资源获取线程的排队工作，如果当前线程获取同步状态（锁）失败时，AQS则会将当前线程以及等待状态等信息构造成一个节点(Node)并将其加入到同步队列，同时会阻塞当前线程，当同步状态释放时，则会把节点中的线程唤醒，使其再次尝试获取同步状态。AQS提供了如下一些主要方法： 1234567891011121314151617181920212223242526272829303132//返回同步状态protected final int getState()//设置当前同步状态protected final void setState(int newState)//使用CAS设置当前状态 该方法能够保证状态设置的原子性protected final boolean compareAndSetState(int expect, int update)//独占式获取同步状态 获取同步状态成功后 其他线程需要等待改线程释放同步状态才能获取同步状态protected boolean tryAcquire(int arg)//独占式释放同步状态protected boolean tryRelease(int arg) //共享式获取同步状态 返回值大于等于0表示获取成功 否则获取失败protected int tryAcquireShared(int arg)//共享式释放同步状态protected boolean tryReleaseShared(int arg)//当前同步器是否在独占式模式下被线程占用 一般该方法表示是否被当前线程所独占protected boolean isHeldExclusively()//独占式获取同步状态，如果当前线程获取同步状态成功，则由该方法返回，否则，将会进入同步队列等待，该方法将会调用可重写的tryAcquire(int arg)方法public final void acquire(int arg)//与acquire相同，但该方法响应中断，当前线程为获取到同步状态而进入到同步队列，如果当前线程被中断，则该方法会抛出InterruptedException异常并返回public final void acquireInterruptibly(int arg) throws InterruptedException//超时获取同步状态，如果当前线程再nanos时间内没有获取到同步状态，那么返回false 已经获取则返回truepublic final boolean tryAcquireNanos(int arg, long nanosTimeout) throws InterruptedException//共享式获取同步状态，如果当前线程未获取到同步状态，将会进入同步队列等待，与独占式的主要区别是在同一时刻可以有多个线程获取到同步状态public final void acquireShared(int arg)//共享式获取同步状态，响应中断public final void acquireSharedInterruptibly(int arg) throws InterruptedException//共享式获取同步状态，增加超时限制public final boolean tryAcquireSharedNanos(int arg, long nanosTimeout) throws InterruptedException//共享式释放同步状态public final boolean releaseShared(int arg)//独占式释放同步状态，该方法会在释放同步状态之后，将同步队列中第一个节点包含的线程唤醒public final boolean release(int arg) CLH同步队列上面提到AQS内部维护了一个FIFO队列，该队列就是CLH同步队列。CLH同步队列是一个FIFO双向队列，AQS依赖它来完成同步状态的管理，当前线程如果获取同步状态失败时，AQS则会将当前线程以及等待状态等信息构造成一个节点(Node)并将其加入到CLH队列，同时会阻塞当前线程，当同步状态释放时会把首节点唤醒(公平锁)，使其再次尝试获取同步状态。CLH同步队列中，一个节点表示一个线程，它保存着线程的引用(thread)、状态(waitStatus)、前驱节点(pred)、后继节点(next),其定义如下： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172static final class Node &#123; //表示节点正在以共享模式等待 static final Node SHARED = new Node(); //表示节点正在以独占模式等待 static final Node EXCLUSIVE = null; //表示节点被取消(超时或中断节点会被设置为取消状态，被取消的节点不会参与到竞争中，会一直保持取消状态不会转变为其他状态) static final int CANCELLED = 1; //表示后继节点的线程需要被唤醒(后继节点的线程处于等待状态，而当前节点的线程如果释放了同步状态或者被取消，将会通知后继节点，使后继节点的线程得以运行) static final int SIGNAL = -1; //表示当前节点在条件队列中，节点线程等待在Condition上(当其他线程对Condition调用了signal()后，该节点将会从等待队列中转移到同步队列中，加入同步状态的获取中) static final int CONDITION = -2; /** * 表示下一次共享模式同步状态获取将会无条件地传播下去 */ static final int PROPAGATE = -3; /** * 对于普通同步节点waitStatus默认为0，条件等待节点为CONDITION，waitStatus通过CAS进行更新 */ volatile int waitStatus; /** * 前驱节点 */ volatile Node prev; /** * 后继节点 */ volatile Node next; /** * 获取同步状态的线程 通过构造器初始化 使用完毕 */ volatile Thread thread; /** * 指向条件队里的下一个节点 */ Node nextWaiter; /** *判断是否为共享模式 */ final boolean isShared() &#123; return nextWaiter == SHARED; &#125; /** * 获取前驱节点 */ final Node predecessor() throws NullPointerException &#123; Node p = prev; if (p == null) throw new NullPointerException(); else return p; &#125; Node() &#123; // Used to establish initial head or SHARED marker &#125; Node(Thread thread, Node mode) &#123; // Used by addWaiter this.nextWaiter = mode; this.thread = thread; &#125; Node(Thread thread, int waitStatus) &#123; // Used by Condition this.waitStatus = waitStatus; this.thread = thread; &#125;&#125; 其中SHARE和EXCLUSIVE常量分别代表共享模式和独占模式共享模式：允许多个获取同步状态，如Semaphore独占模式：同一时间只能有一个线程获取同步状态，多余的线程则需要排队等待 如ReentrantLock变量waitStatus表示当前构造的Node节点的等待状态，共有4中：SIGNAL、CANCELLED、CONDITION、PROPAGATE： CANCELLED：值为1，在同步队列等待的线程等待超时或被中断，需要从同步队列中取消该Node的节点，其节点的waitStatus为CANCELLED，即结束状态，进入该状态后的节点将不会再变化 SIGNAL：值为-1，被标识为该等待唤醒状态的后继节点，当其前继节点的线程释放了同步锁或被取消，将会通知该后继节点的线程执行。(即：处于唤醒状态，只要前继节点释放锁，就会通知标识为signal状态的后继节点线程执行) CONDITION：值为-2，与Condition相关，该标识的节点处于条件队列中，节点的线程等待在Condition上，其他线程调用了Condition的signal()方法后，CONDITION状态节点从条件队列转移到同步队列中，等待获取同步锁 PROPAGATE：值为-3，与共享模式相关，在共享模式中，该标识节点的线程处于可运行状态。 0状态：值为0，代表初识化状态 入队CLH入队操作即tail指向新节点、新节点的prev指向当前最后节点，当前最后节点next指向新节点 12345678910111213141516171819202122232425262728293031private Node addWaiter(Node mode) &#123; //构造节点 Node node = new Node(Thread.currentThread(), mode); // 快速尝试添加尾结点 入队 Node pred = tail; if (pred != null) &#123; node.prev = pred; if (compareAndSetTail(pred, node)) &#123; pred.next = node; return node; &#125; &#125; enq(node); return node;&#125;//若快速设置尾结点失败 则执行enq操作private Node enq(final Node node) &#123; for (;;) &#123; Node t = tail; if (t == null) &#123; // Must initialize if (compareAndSetHead(new Node())) tail = head; &#125; else &#123; node.prev = t; if (compareAndSetTail(t, node)) &#123; t.next = node; return t; &#125; &#125; &#125;&#125; 出队CLH同步队列遵循FIFO，首节点的线程释放同步状态后，将会唤醒它的后继节点，而后继节点将会在获取同步状态成功时将自己设置为首节点（head执行该节点并断开原首节点的next和当前节点的prev即可，此过程不需要CAS来保证，因为只有一个线程能够成功获取到同步状态） 同步状态的获取与释放AQS的设计模式采用了模板方法模式，子类通过继承并重写特定方法来管理同步状态。其具有两种模式：独占模式和共享模式 独占模式独占模式同一时刻只有一个线程持有同步状态 12345public final void acquire(int arg) &#123; if (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg)) selfInterrupt();&#125; tryAcquire(arg)尝试获取同步状态 获取成功返回true否则返回false 此方法由自定义同步组件实现，必须保证线程安全获取同步状态 addWaiter(Node.EXCLUSIVE)tryAcquire获取失败，则调用此方法将当前线程放入CLH同步队列尾部 acquireQueued() 当前线程根据公平性原则来进行阻塞等待(自旋)，直到获取锁为止 并且返回当前线程在等待过程中有没有中断过 selfInterrupt 产生一个中断 即每个线程如果获取同步状态失败，加入到CLH同步队列后就会进入acquireQueued()自旋，当条件满足获取同步状态成功从自旋中退出，否则一直执行下去。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556final boolean acquireQueued(final Node node, int arg) &#123; boolean failed = true; try &#123; //中断标志 boolean interrupted = false; for (;;) &#123;//自旋过程 final Node p = node.predecessor(); //如果当前节点的前继节点是头结点并且获取同步状态成功 if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return interrupted; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125;private static boolean shouldParkAfterFailedAcquire(Node pred, Node node) &#123; int ws = pred.waitStatus; if (ws == Node.SIGNAL) /* * This node has already set status asking a release * to signal it, so it can safely park. */ return true; if (ws &gt; 0) &#123;//前驱节点状态为CANCELLED被中断或被取消，需要从同步队列中移除 /* * Predecessor was cancelled. Skip over predecessors and * indicate retry. */ do &#123; node.prev = pred = pred.prev; &#125; while (pred.waitStatus &gt; 0); pred.next = node; &#125; else &#123;//前驱节点状态为CONDITION、PROPAGATE /* * waitStatus must be 0 or PROPAGATE. Indicate that we * need a signal, but don't park yet. Caller will need to * retry to make sure it cannot acquire before parking. */ compareAndSetWaitStatus(pred, ws, Node.SIGNAL); &#125; return false;&#125;private final boolean parkAndCheckInterrupt() &#123; LockSupport.park(this); return Thread.interrupted();&#125; 独占模式获取响应中断AQS提供了acquireInterruptibly(int arg)方法，该方法在等待获取同步状态时，如果当前线程被中断了，会立刻响应中断抛出异常InterruptedException 123456789101112131415161718192021222324252627282930public final void acquireInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (!tryAcquire(arg)) doAcquireInterruptibly(arg);&#125;private void doAcquireInterruptibly(int arg) throws InterruptedException &#123; final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 与acquire(int arg)方法区别： 方法声明抛出了InterruptedException异常 在中断方法处不再使用Interrupted标识，而是直接抛出InterruptedException异常 独占模式超时获取AQS还提供了一个增强版本的方法tryAcquireNanos(int arg,long nanos)。该方法是acquireInterruptibly方法的进一步增强，它除了响应中断外，还有超时控制。即如果线程没有在指定时间内获取同步状态，则会返回false 否则返回true 123456789101112131415161718192021222324252627282930313233343536373839public final boolean tryAcquireNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); return tryAcquire(arg) || doAcquireNanos(arg, nanosTimeout);&#125;private boolean doAcquireNanos(int arg, long nanosTimeout) throws InterruptedException &#123; if (nanosTimeout &lt;= 0L) return false; final long deadline = System.nanoTime() + nanosTimeout; final Node node = addWaiter(Node.EXCLUSIVE); boolean failed = true; try &#123; for (;;) &#123; final Node p = node.predecessor(); if (p == head &amp;&amp; tryAcquire(arg)) &#123; setHead(node); p.next = null; // help GC failed = false; return true; &#125; nanosTimeout = deadline - System.nanoTime(); if (nanosTimeout &lt;= 0L)//已经超时返回false return false; //若未超时则等待nanosTimeout纳秒 if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; nanosTimeout &gt; spinForTimeoutThreshold) LockSupport.parkNanos(this, nanosTimeout); if (Thread.interrupted())//线程是否已经中断 throw new InterruptedException(); &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 独占模式同步状态释放当线程后期同步状态后，执行完响应逻辑就需要释放同步状态。AQS提供了release(int arg)方法释放同步状态123456789101112131415161718192021222324252627282930313233343536public final boolean release(int arg) &#123; if (tryRelease(arg)) &#123; Node h = head; if (h != null &amp;&amp; h.waitStatus != 0) unparkSuccessor(h); return true; &#125; return false;&#125;private void unparkSuccessor(Node node) &#123; /* * If status is negative (i.e., possibly needing signal) try * to clear in anticipation of signalling. It is OK if this * fails or if status is changed by waiting thread. */ int ws = node.waitStatus; if (ws &lt; 0) compareAndSetWaitStatus(node, ws, 0); /* * Thread to unpark is held in successor, which is normally * just the next node. But if cancelled or apparently null, * traverse backwards from tail to find the actual * non-cancelled successor. */ Node s = node.next; if (s == null || s.waitStatus &gt; 0) &#123; s = null; for (Node t = tail; t != null &amp;&amp; t != node; t = t.prev) if (t.waitStatus &lt;= 0) s = t; &#125; if (s != null) LockSupport.unpark(s.thread);&#125; 首先调用tryRelease(int arg)方法，若调用成功则通过unparkSuccessor(Node)唤醒后继节点 小结独占模式下AQS维护这一个FIFO同步队列，线程获取同步状态失败时进入同步队列等待，同时进入自旋 不断检查前继节点是否是头结点，如果是，则尝试获取同步状态。若获取成功则退出同步队列，当线程执行完逻辑后，释放会唤醒其后继节点。 共享模式共享模式和独占模式最大的区别是：同一时刻独占模式只能有一个线程获取同步状态，而共享模式在同一时刻可以有多个线程获取同步状态。 共享模式同步状态获取AQS提供了acquireShared(int arg)方法共享获取同步状态：1234public final void acquireShared(int arg) &#123; if (tryAcquireShared(arg) &lt; 0) doAcquireShared(arg);&#125;方法通过调用tryAcquireShared(int arg)尝试获取同步状态，若获取失败则调用doAcquireShared(int arg)自旋方式获取同步状态，共享模式获取同步状态的标识是返回&gt;=0 的值表示获取成功。 1234567891011121314151617181920212223242526272829private void doAcquireShared(int arg) &#123; //构建共享模式的节点 final Node node = addWaiter(Node.SHARED); boolean failed = true; try &#123; boolean interrupted = false; for (;;) &#123; final Node p = node.predecessor(); if (p == head) &#123; int r = tryAcquireShared(arg); if (r &gt;= 0) &#123; setHeadAndPropagate(node, r); p.next = null; // help GC if (interrupted) selfInterrupt(); failed = false; return; &#125; &#125; if (shouldParkAfterFailedAcquire(p, node) &amp;&amp; parkAndCheckInterrupt()) interrupted = true; &#125; &#125; finally &#123; if (failed) cancelAcquire(node); &#125;&#125; 如果节点的前继节点是头结点则通过tryAcquireShared(int arg)尝试获取同步状态，获取成功则退出自旋acquireShared(int arg)不响应中断，与独占模式类似，也提供了响应中断、超时的方法：acquireSharedInterruptibly(int arg)、tryAcquireSharedNanos(int arg,long nanos)。 共享模式同步状态释放获取同步状态后，共享模式通过调用releaseShared(int arg)释放同步状态：123456789101112131415161718192021222324252627282930313233343536public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125;private void doReleaseShared() &#123; /* * Ensure that a release propagates, even if there are other * in-progress acquires/releases. This proceeds in the usual * way of trying to unparkSuccessor of head if it needs * signal. But if it does not, status is set to PROPAGATE to * ensure that upon release, propagation continues. * Additionally, we must loop in case a new node is added * while we are doing this. Also, unlike other uses of * unparkSuccessor, we need to know if CAS to reset status * fails, if so rechecking. */ for (;;) &#123; Node h = head; if (h != null &amp;&amp; h != tail) &#123; int ws = h.waitStatus; if (ws == Node.SIGNAL) &#123; if (!compareAndSetWaitStatus(h, Node.SIGNAL, 0)) continue; // loop to recheck cases unparkSuccessor(h); &#125; else if (ws == 0 &amp;&amp; !compareAndSetWaitStatus(h, 0, Node.PROPAGATE)) continue; // loop on failed CAS &#125; if (h == head) // loop if head changed break; &#125;&#125; 因为共享模式可能会存在多个线程同时进行释放同步状态资源，需要确保同步状态安全地成功释放，故利用CAS和自旋来保证。]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发笔记之Semaphore分析]]></title>
    <url>%2FJava%E5%B9%B6%E5%8F%91%2F%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B9%8BSemaphore%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[Semaphore是一个计数信号量。从概念上讲，信号量维护了一组许可，每个acquire操作都会阻塞直到有一个许可可用然后使用这个许可。每个release相当于会添加一个许可，同时潜在也就是释放了一个阻塞的acquire。但是并没有一个实际的许可对象，信号量只是根据计数来采取相应的行动。 主要属性12345678910public class Semaphore implements java.io.Serializable &#123; private static final long serialVersionUID = -3222578661600680210L; /** All mechanics via AbstractQueuedSynchronizer subclass */ private final Sync sync; public Semaphore(int permits) &#123; sync = new NonfairSync(permits); &#125; public Semaphore(int permits, boolean fair) &#123; sync = fair ? new FairSync(permits) : new NonfairSync(permits); &#125; 可见Semaphore内部实现依赖于Sync，而Sync继承自AQS，并且其构造器接受可选项fair来控制使用公平还是非公平版本的信号量。 内部类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051abstract static class Sync extends AbstractQueuedSynchronizer &#123; private static final long serialVersionUID = 1192457210091910933L; Sync(int permits) &#123; setState(permits); &#125; final int getPermits() &#123; return getState(); &#125; final int nonfairTryAcquireShared(int acquires) &#123; for (;;) &#123; int available = getState(); int remaining = available - acquires; if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; &#125; &#125; protected final boolean tryReleaseShared(int releases) &#123; for (;;) &#123; int current = getState(); int next = current + releases; if (next &lt; current) // overflow throw new Error("Maximum permit count exceeded"); if (compareAndSetState(current, next)) return true; &#125; &#125; final void reducePermits(int reductions) &#123; for (;;) &#123; int current = getState(); int next = current - reductions; if (next &gt; current) // underflow throw new Error("Permit count underflow"); if (compareAndSetState(current, next)) return; &#125; &#125; final int drainPermits() &#123; for (;;) &#123; int current = getState(); if (current == 0 || compareAndSetState(current, 0)) return current; &#125; &#125;&#125; 非公平版本1234567891011static final class NonfairSync extends Sync &#123; private static final long serialVersionUID = -2694183684443567898L; NonfairSync(int permits) &#123; super(permits); &#125; protected int tryAcquireShared(int acquires) &#123; return nonfairTryAcquireShared(acquires); &#125;&#125; 公平版本12345678910111213141516171819static final class FairSync extends Sync &#123; private static final long serialVersionUID = 2014338818796000944L; FairSync(int permits) &#123; super(permits); &#125; protected int tryAcquireShared(int acquires) &#123; for (;;) &#123; if (hasQueuedPredecessors()) return -1; int available = getState(); int remaining = available - acquires; if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; &#125; &#125;&#125; acquire1234567891011121314151617181920212223242526272829303132333435public void acquire() throws InterruptedException &#123; sync.acquireSharedInterruptibly(1);&#125;public final void acquireSharedInterruptibly(int arg) throws InterruptedException &#123; if (Thread.interrupted()) throw new InterruptedException(); if (tryAcquireShared(arg) &lt; 0) doAcquireSharedInterruptibly(arg);&#125;//非公平版本protected int tryAcquireShared(int acquires) &#123; return nonfairTryAcquireShared(acquires);&#125;final int nonfairTryAcquireShared(int acquires) &#123; for (;;) &#123; int available = getState(); int remaining = available - acquires; if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; &#125;&#125;//公平版本protected int tryAcquireShared(int acquires) &#123; for (;;) &#123; if (hasQueuedPredecessors()) return -1; int available = getState(); int remaining = available - acquires; if (remaining &lt; 0 || compareAndSetState(available, remaining)) return remaining; &#125;&#125; release123456789101112131415161718192021 public void release(int permits) &#123; if (permits &lt; 0) throw new IllegalArgumentException(); sync.releaseShared(permits);&#125;public final boolean releaseShared(int arg) &#123; if (tryReleaseShared(arg)) &#123; doReleaseShared(); return true; &#125; return false;&#125;protected final boolean tryReleaseShared(int releases) &#123; for (;;) &#123; int current = getState(); int next = current + releases; if (next &lt; current) // overflow throw new Error("Maximum permit count exceeded"); if (compareAndSetState(current, next)) return true; &#125;&#125; 没啥好讲的 也是利用AQS来实现，Semphore初始化一个给定的值，这个值最终被作为同步状态的值，acquire操作无论公平还是非公平版本，每次竞争获取并更新同步状态自减一只要是int remaining = available - acquires;剩余“许可数”大于等于0 这即可获得锁。而release操作每次成功则将同步状态增一，相当于添加了一个“许可”。]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发笔记之CyclicBarrier分析]]></title>
    <url>%2FJava%E5%B9%B6%E5%8F%91%2F%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B9%8BCyclicBarrier%E5%88%86%E6%9E%90%2F</url>
    <content type="text"><![CDATA[CyclicBarrier是一个同步辅助类，允许一组线程互相等待直到到达一个公共屏障点(common barrier),当涉及到一组固定大小必须相互等待的线程是非常有用的。他之所以称为cyclic是因为当线程释放，CyclicBarrier可以被重复使用。 主要属性123456789101112131415161718public class CyclicBarrier &#123; /** The lock for guarding barrier entry */ private final ReentrantLock lock = new ReentrantLock(); /** Condition to wait on until tripped */ private final Condition trip = lock.newCondition(); /** The number of parties */ private final int parties; /* The command to run when tripped */ private final Runnable barrierCommand; /** The current generation */ private Generation generation = new Generation(); /** * 等待的线程数每一代从parties递减到0 * 当Barrier breaken或者新的一代开始 被重置为parties */ private int count; 构造器123456789public CyclicBarrier(int parties) &#123; this(parties, null);&#125;public CyclicBarrier(int parties, Runnable barrierAction) &#123; if (parties &lt;= 0) throw new IllegalArgumentException(); this.parties = parties; this.count = parties; this.barrierCommand = barrierAction;&#125; 其构造其有两个参数： parties:表示参与的线程数 barriesAction：当达到给定数量的线程处于等待状态 启动barrier时执行给定的屏障操作，此操作由最后进入barrier的线程执行。 等待 await1234567public int await() throws InterruptedException, BrokenBarrierException &#123; try &#123; return dowait(false, 0L); &#125; catch (TimeoutException toe) &#123; throw new Error(toe); // cannot happen &#125;&#125; await()最终调用的是超时版本的dowait12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667private int dowait(boolean timed, long nanos) throws InterruptedException, BrokenBarrierException, TimeoutException &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; final Generation g = generation; //当前generation已损坏 则抛出BrokenBarrierException异常 if (g.broken) throw new BrokenBarrierException(); //线程中断则终止barrier if (Thread.interrupted()) &#123; breakBarrier(); throw new InterruptedException(); &#125; //进来一个线程 count自减一 int index = --count; if (index == 0) &#123; // index==0 表示线程都到位 则执行Runnable任务 boolean ranAction = false; try &#123; final Runnable command = barrierCommand; if (command != null) command.run();//出发屏障任务 ranAction = true; nextGeneration();//唤醒所有等待任务 并更新generation return 0; &#125; finally &#123; if (!ranAction) breakBarrier(); &#125; &#125; // loop until tripped, broken, interrupted, or timed out for (;;) &#123; try &#123; if (!timed)//非超时等待 调用Condition.await()一直等待 trip.await(); else if (nanos &gt; 0L)//超时等待 nanos = trip.awaitNanos(nanos); &#125; catch (InterruptedException ie) &#123; if (g == generation &amp;&amp; ! g.broken) &#123; breakBarrier(); throw ie; &#125; else &#123; // We're about to finish waiting even if we had not // been interrupted, so this interrupt is deemed to // "belong" to subsequent execution. Thread.currentThread().interrupt(); &#125; &#125; if (g.broken) throw new BrokenBarrierException(); if (g != generation)//generation已更新 返回index return index; if (timed &amp;&amp; nanos &lt;= 0L) &#123;//等待超时 终止barrier 并抛出异常 breakBarrier(); throw new TimeoutException(); &#125; &#125; &#125; finally &#123; lock.unlock(); &#125; &#125; 换代当线程都到位，并且最后一个进入的线程成功执行了屏障任务，则调用nextGeneration()方法进行换代 并唤醒所有线程1234567private void nextGeneration() &#123; // signal completion of last generation trip.signalAll(); // set up next generation count = parties; generation = new Generation();&#125; 终止Barrier当线程被中断或线程等待超时 则调用breakBarrier()方法终止Barrier12345private void breakBarrier() &#123; generation.broken = true; count = parties; trip.signalAll();&#125;]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[并发笔记之Synchronized实现原理]]></title>
    <url>%2FJava%E5%B9%B6%E5%8F%91%2F%E5%B9%B6%E5%8F%91%E7%AC%94%E8%AE%B0%E4%B9%8BSynchronized%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[初识java解决线程并发问题，首先想到的可能就是synchronized关键字，操作简单；但相对于Lock，synchronized是一个重量级锁 并不是那么高效但JDK1.6对其进行了各种优化后，性能有了很大提升。那么synchronized的实现机制是什么？JDK是如果对它进行优化以及锁优化机制、锁的存储结构和升级过程是什么样的呢？ 实现原理 synchronized可以保证方法或者代码块在运行时，同一时刻只有一个方法可以进入临界区，同时它可以保证共享变量的内存可见性。 Java中每个对象都可以作为锁 普通同步方法 锁是当前实例对象 静态同步方法 锁是当前类的class对象 同步方法块 锁是括号内的对象 举个栗子 123456789public class Hello &#123; public synchronized void hello1()&#123; &#125; public void hello2()&#123; synchronized(this)&#123; &#125; &#125;&#125; javap -verbose反编译下代码看看：12345678910111213141516171819202122232425262728293031323334353637383940414243public synchronized void hello1(); descriptor: ()V flags: ACC_PUBLIC, ACC_SYNCHRONIZED Code: stack=0, locals=1, args_size=1 0: return LineNumberTable: line 4: 0 public void hello2(); descriptor: ()V flags: ACC_PUBLIC Code: stack=2, locals=3, args_size=1 0: aload_0 1: dup 2: astore_1 3: monitorenter 4: aload_1 5: monitorexit 6: goto 14 9: astore_2 10: aload_1 11: monitorexit 12: aload_2 13: athrow 14: return Exception table: from to target type 4 6 9 any 9 12 9 any LineNumberTable: line 6: 0 line 7: 4 line 8: 14 StackMapTable: number_of_entries = 2 frame_type = 255 /* full_frame */ offset_delta = 9 locals = [ class Hello, class java/lang/Object ] stack = [ class java/lang/Throwable ] frame_type = 250 /* chop */ offset_delta = 4反编译后可以看出 同步方法 JVM采用了ACC_SYNCHRONIZED 将该方法的access_flags字段中的synchronized标志置为1，表示该方法是同步方法并使用调用该方法的对象或该方法所属Class在JVM内部对象Klass作为锁对象 同步代码块 在同步代码块的入口和出口位置分别插入字节码指令monitorenter和moniterexit Java对象模型Java对象保存在堆内存中，一个对象包含三部分：对象头、实例数据和对齐填充。我们对对象进行操作时其实操作的是对象的引用，那么对象在堆内存中的存储结构是什么样的呢？以HotSpot虚拟机为例 OPP-Klass ModelHotSpot JVM是基于C++实现，C++本身也是一种面向对象的语言，故Java中的对象表示最简单的就是为每个Java对象生成一个C++对象与之对应。但HotSpot没这么做，而是设计了一个OPP-Klass Model:OPP就是普通对象指针（Ordinary Object Pointer）,Klass是描述对象实例的具体类型 Java对象头和monitor是实现synchronized的基础 对象头synchronized使用的锁在对象头里，HotSpot虚拟机的对象头主要包括两部分数据： Mark Word(标记字段):存储对象自身的运行时数据 它是现实轻量级锁和偏向锁的关键 Klass Pointer(类型指针):对象指向其类元素据的指针 虚拟机通过这个指针来判断对象是哪个类的实例 当我们在Java代码中，使用new创建一个对象实例的时候，（hotspot虚拟机）JVM层面实际上会创建一个 instanceOopDesc对象。Hotspot虚拟机采用OOP-Klass模型来描述Java对象实例，OOP(Ordinary Object Point)指的是普通对象指针，Klass用来描述对象实例的具体类型。Hotspot采用instanceOopDesc和arrayOopDesc来描述对象头，arrayOopDesc对象用来描述数组类型instanceOopDesc的定义在Hotspot源码中的 instanceOop.hpp文件中，另外，arrayOopDesc的定义对应 arrayOop.hpp从instanceOopDesc代码中可以看到 instanceOopDesc继承自oopDesc，oopDesc的定义载Hotspot源码中的 oop.hpp文件中在普通实例对象中，oopDesc的定义包含两个成员，分别是 _mark和 _metadata_mark表示对象标记、属于markOop类型，也就是接下来要讲解的Mark World，它记录了对象和锁有关的信息_metadata表示类元信息，类元信息存储的是对象指向它的类元数据(Klass)的首地址，其中Klass表示普通指针、 _compressed_klass表示压缩类指针 Mark Word普通对象的对象头由两部分组成，分别是markOop以及类元信息，markOop官方称为Mark Word 在Hotspot中，markOop的定义在 markOop.hpp文件中，代码如下Mark word记录了对象和锁有关的信息，当某个对象被synchronized关键字当成同步锁时，那么围绕这个锁的一系列操作都和Mark word有关系。Mark Word在32位虚拟机的长度是32bit、在64位虚拟机的长度是64bit。 Mark Word存储的对象运行时数据，如哈希码(HashCode)、垃圾回收分代年龄、线程持有的锁、锁状态标志、偏向线程ID、偏向时间戳等。Java对象头一般占有两个机器码(32位虚拟机中，1个机器码等于4个字节，也就是32bit)，但如果是数组则需要三个机器码，因为JVM可以通过Java对象的元数据信息确定Java对象的大小，但是无法从数组的元数据来确定数组大小，故用一块单独的内存记录数组长度。Java对象头存储结构如下(32位)： 25bit 4bit 1bit 2bit 对象的HashCode 对象的分代年龄 是否是偏向锁 锁标志位 对象头信息是与对象自身定义的数据无关的额外存储成本，但考虑到虚拟机的空间效率，Mark Word被设计成一个非固定地的数据结构以便在极小的空间内存存储尽量多的数据，它会根据对象的状态复用自己的存储空间，也就是，Mark Word会根据程序运行的变化，变化状态如下(32位虚拟机)： Monitor通过字节码我们可以发现，修饰在方法层面的同步关键字，会多一个 ACC_SYNCHRONIZED的flag；修饰在代码块层面的同步块会多一个 monitorenter和 monitorexit关键字。无论采用哪一种方式，本质上都是对一个对象的监视器(monitor)进行获取，而这个获取的过程是排他的，也就是同一个时刻只能有一个线程获得同步块对象的监视器。synchronized关键字经过编译之后，会在同步块的前后分别形成monitorenter和monitorexit这两个字节码指令。当我们的JVM把字节码加载到内存的时候，会对这两个指令进行解析。这两个字节码都需要一个Object类型的参数来指明要锁定和解锁的对象。如果Java程序中的synchronized明确指定了对象参数，那么这个对象就是加锁和解锁的对象；如果没有明确指定，那就根据synchronized修饰的是实例方法还是类方法，获取对应的对象实例或Class对象来作为锁对象 其实前面只提到了锁标志位的存储，但是为什么任意一个Java对象都能成为锁对象呢？首先，Java中的每个对象都派生自Object类，而每个Java Object在JVM内部都有一个native的C++对象 oop/oopDesc进行对应。其次，线程在获取锁的时候，实际上就是获得一个监视器对象(monitor) ,monitor可以认为是一个同步对象，所有的Java对象是天生携带monitor.在hotspot源码的 markOop.hpp文件中多个线程访问同步代码块时，相当于去争抢对象监视器修改对象中的锁标识,上面的代码中ObjectMonitor这个对象和线程争抢锁的逻辑有密切的关系(后续会详细分析) 锁升级在JDK1.6之前，synchronized是一个重量级锁，性能比较差。从JDK1.6开始，为了减少获得锁和释放锁带来的性能消耗，synchronized进行了优化，引入了 偏向锁和 轻量级锁的概念。所以从JDK1.6开始，锁一共会有四种状态，锁的状态根据竞争激烈程度从低到高分别是:无锁状态-&gt;偏向锁状态-&gt;轻量级锁状态-&gt;重量级锁状态。这几个状态会随着锁竞争的情况逐步升级。为了提高获得锁和释放锁的效率，锁可以升级但是不能降级。 偏向锁在大多数的情况下，锁不仅不存在多线程的竞争，而且总是由同一个线程获得。因此为了让线程获得锁的代价更低引入了偏向锁的概念。偏向锁的意思是如果一个线程获得了一个偏向锁，如果在接下来的一段时间中没有其他线程来竞争锁，那么持有偏向锁的线程再次进入或者退出同一个同步代码块，不需要再次进行抢占锁和释放锁的操作。偏向锁可以通过 -XX:+UseBiasedLocking开启或者关闭 偏向锁获取偏向锁的获取过程非常简单，当一个线程访问同步块获取锁时，会在对象头和栈帧中的锁记录里存储偏向锁的线程ID，表示哪个线程获得了偏向锁，结合前面分析的Mark Word来分析一下偏向锁的获取逻辑 首先获取目标对象的Mark Word，根据锁的标识为和epoch去判断当前是否处于可偏向的状态 如果为可偏向状态，则通过CAS操作将自己的线程ID写入到MarkWord，如果CAS操作成功，则表示当前线程成功获取到偏向锁，继续执行同步代码块 如果是已偏向状态，先检测MarkWord中存储的threadID和当前访问的线程的threadID是否相等，如果相等，表示当前线程已经获得了偏向锁，则不需要再获得锁直接执行同步代码；如果不相等，则证明当前锁偏向于其他线程，需要撤销偏向锁。 CAS:表示自旋锁，由于线程的阻塞和唤醒需要CPU从用户态转为核心态，频繁的阻塞和唤醒对CPU来说性能开销很大。同时，很多对象锁的锁定状态指会持续很短的时间，因此引入了自旋锁，所谓自旋就是一个无意义的死循环，在循环体内不断的重行竞争锁。当然，自旋的次数会有限制，超出指定的限制会升级到阻塞锁。 偏向锁撤销当其他线程尝试竞争偏向锁时，持有偏向锁的线程才会释放偏向锁，撤销偏向锁的过程需要等待一个全局安全点(所有工作线程都停止字节码的执行)。 首先，暂停拥有偏向锁的线程，然后检查偏向锁的线程是否为存活状态 如果线程已经死了，直接把对象头设置为无锁状态 如果还活着，当达到全局安全点时获得偏向锁的线程会被挂起，接着偏向锁升级为轻量级锁，然后唤醒被阻塞在全局安全点的线程继续往下执行同步代码 轻量级锁当存在超过一个线程在竞争同一个同步代码块时，会发生偏向锁的撤销。偏向锁撤销以后对象会可能会处于两种状态 一种是不可偏向的无锁状态，简单来说就是已经获得偏向锁的线程已经退出了同步代码块，那么这个时候会撤销偏向锁，并升级为轻量级锁 一种是不可偏向的已锁状态，简单来说就是已经获得偏向锁的线程正在执行同步代码块，那么这个时候会升级到轻量级锁并且被原持有锁的线程获得锁 轻量级锁加锁 JVM会先在当前线程的栈帧中创建用于存储锁记录的空间(LockRecord) 将对象头中的Mark Word复制到锁记录中，称为Displaced Mark Word. 线程尝试使用CAS将对象头中的Mark Word替换为指向锁记录的指针 如果替换成功，表示当前线程获得轻量级锁，如果失败，表示存在其他线程竞争锁，那么当前线程会尝试使用CAS来获取锁，当自旋超过指定次数(可以自定义)时仍然无法获得锁，此时锁会膨胀升级为重量级锁 轻量级锁解锁 尝试CAS操作将所记录中的Mark Word替换回到对象头中 如果成功，表示没有竞争发生 如果失败，表示当前锁存在竞争，锁会膨胀成重量级锁 重量级锁重量级锁依赖对象内部的monitor锁来实现，而monitor又依赖操作系统的MutexLock（互斥锁）假设Mutex变量的值为1，表示互斥锁空闲，这个时候某个线程调用lock可以获得锁，而Mutex的值为0表示互斥锁已经被其他线程获得，其他线程调用lock只能挂起等待 为什么重量级锁的开销比较大呢？原因是当系统检查到是重量级锁之后，会把等待想要获取锁的线程阻塞，被阻塞的线程不会消耗CPU，但是阻塞或者唤醒一个线程，都需要通过操作系统来实现，也就是相当于从用户态转化到内核态，而转化状态是需要消耗时间的 锁优化JVM中monitorenter和moniterexit字节码指令依赖于底层的操作系统mutex lock实现，但mutex lock需要将当前线程挂起并从用户态切换到内核态来执行，切换代价比较高昂。实际使用过程中，大部分情况下同步方法是运行在单线程环境若每次都调用mutex lock将严重影响性能。好在JDK1.6对锁的实现引入了大量的优化,来减少锁操作的开销： 锁粗化(lock coarsening)将不必要的连续的lock、unlock操作扩展成一个更大范围的锁 锁消除(lock elimination)通过运行时JIT编译器的逃逸分析来消除一些没有在当前同步块以外被其他线程共享的数据的锁保护 轻量级锁(lightweight locking) 偏向锁(biased locking) 适应性自旋锁(adaptive spinning) synchronized的源码分析]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Concurrent</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConcurrentHashMap]]></title>
    <url>%2FJava%E9%9B%86%E5%90%88%2FConcurrentHashMap%2F</url>
    <content type="text"><![CDATA[ConcurrentHashMap是HashMap的线程安全版本，内部也是使用数组、链表、红黑树的结构存储元素。 其继承关系如下： 主要属性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990public class ConcurrentHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements ConcurrentMap&lt;K,V&gt;, Serializable &#123; private static final long serialVersionUID = 7249069246763182397L; private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; private static final int DEFAULT_CAPACITY = 16; static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; private static final int DEFAULT_CONCURRENCY_LEVEL = 16; private static final float LOAD_FACTOR = 0.75f; static final int TREEIFY_THRESHOLD = 8; static final int UNTREEIFY_THRESHOLD = 6; static final int MIN_TREEIFY_CAPACITY = 64; private static final int MIN_TRANSFER_STRIDE = 16; private static int RESIZE_STAMP_BITS = 16; private static final int MAX_RESIZERS = (1 &lt;&lt; (32 - RESIZE_STAMP_BITS)) - 1; private static final int RESIZE_STAMP_SHIFT = 32 - RESIZE_STAMP_BITS; /* * Encodings for Node hash fields. See above for explanation. */ static final int MOVED = -1; // hash for forwarding nodes static final int TREEBIN = -2; // hash for roots of trees static final int RESERVED = -3; // hash for transient reservations static final int HASH_BITS = 0x7fffffff; // usable bits of normal node hash /** Number of CPUS, to place bounds on some sizings */ static final int NCPU = Runtime.getRuntime().availableProcessors(); /** For serialization compatibility. */ private static final ObjectStreamField[] serialPersistentFields = &#123; new ObjectStreamField("segments", Segment[].class), new ObjectStreamField("segmentMask", Integer.TYPE), new ObjectStreamField("segmentShift", Integer.TYPE) &#125;; transient volatile Node&lt;K,V&gt;[] table; /** * The next table to use; non-null only while resizing. */ private transient volatile Node&lt;K,V&gt;[] nextTable; /** * Base counter value, used mainly when there is no contention, * but also as a fallback during table initialization * races. Updated via CAS. */ private transient volatile long baseCount; /** * Table initialization and resizing control. When negative, the * table is being initialized or resized: -1 for initialization, * else -(1 + the number of active resizing threads). Otherwise, * when table is null, holds the initial table size to use upon * creation, or 0 for default. After initialization, holds the * next element count value upon which to resize the table. */ private transient volatile int sizeCtl; /** * The next table index (plus one) to split while resizing. */ private transient volatile int transferIndex; /** * Spinlock (locked via CAS) used when resizing and/or creating CounterCells. */ private transient volatile int cellsBusy; /** * Table of counter cells. When non-null, size is a power of 2. */ private transient volatile CounterCell[] counterCells; // views private transient KeySetView&lt;K,V&gt; keySet; private transient ValuesView&lt;K,V&gt; values; private transient EntrySetView&lt;K,V&gt; entrySet; ... ...&#125; 内部类1234567891011121314static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; volatile V val; volatile Node&lt;K,V&gt; next; Node(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.val = val; this.next = next; &#125; ... ...&#125; 构造器1234567891011121314151617181920212223242526272829303132public ConcurrentHashMap() &#123;&#125;public ConcurrentHashMap(int initialCapacity) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException(); int cap = ((initialCapacity &gt;= (MAXIMUM_CAPACITY &gt;&gt;&gt; 1)) ? MAXIMUM_CAPACITY : tableSizeFor(initialCapacity + (initialCapacity &gt;&gt;&gt; 1) + 1)); this.sizeCtl = cap;&#125;public ConcurrentHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.sizeCtl = DEFAULT_CAPACITY; putAll(m);&#125;public ConcurrentHashMap(int initialCapacity, float loadFactor) &#123; this(initialCapacity, loadFactor, 1);&#125;public ConcurrentHashMap(int initialCapacity, float loadFactor, int concurrencyLevel) &#123; if (!(loadFactor &gt; 0.0f) || initialCapacity &lt; 0 || concurrencyLevel &lt;= 0) throw new IllegalArgumentException(); if (initialCapacity &lt; concurrencyLevel) // Use at least as many bins initialCapacity = concurrencyLevel; // as estimated threads long size = (long)(1.0 + (long)initialCapacity / loadFactor); int cap = (size &gt;= (long)MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : tableSizeFor((int)size); this.sizeCtl = cap;&#125; 添加元素12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667public V put(K key, V value) &#123; return putVal(key, value, false);&#125;final V putVal(K key, V value, boolean onlyIfAbsent) &#123; if (key == null || value == null) throw new NullPointerException(); int hash = spread(key.hashCode()); int binCount = 0; for (Node&lt;K,V&gt;[] tab = table;;) &#123; Node&lt;K,V&gt; f; int n, i, fh; if (tab == null || (n = tab.length) == 0) tab = initTable(); else if ((f = tabAt(tab, i = (n - 1) &amp; hash)) == null) &#123; if (casTabAt(tab, i, null, new Node&lt;K,V&gt;(hash, key, value, null))) break; // no lock when adding to empty bin &#125; else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else &#123; V oldVal = null; synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; if (fh &gt;= 0) &#123; binCount = 1; for (Node&lt;K,V&gt; e = f;; ++binCount) &#123; K ek; if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; oldVal = e.val; if (!onlyIfAbsent) e.val = value; break; &#125; Node&lt;K,V&gt; pred = e; if ((e = e.next) == null) &#123; pred.next = new Node&lt;K,V&gt;(hash, key, value, null); break; &#125; &#125; &#125; else if (f instanceof TreeBin) &#123; Node&lt;K,V&gt; p; binCount = 2; if ((p = ((TreeBin&lt;K,V&gt;)f).putTreeVal(hash, key, value)) != null) &#123; oldVal = p.val; if (!onlyIfAbsent) p.val = value; &#125; &#125; &#125; &#125; if (binCount != 0) &#123; if (binCount &gt;= TREEIFY_THRESHOLD) treeifyBin(tab, i); if (oldVal != null) return oldVal; break; &#125; &#125; &#125; addCount(1L, binCount); return null;&#125; 初始化桶数组123456789101112131415161718192021222324252627282930313233343536private final Node&lt;K,V&gt;[] initTable() &#123; Node&lt;K,V&gt;[] tab; int sc; while ((tab = table) == null || tab.length == 0) &#123; if ((sc = sizeCtl) &lt; 0)//如果sizeCtl小于0 表示正在初始化或者扩容，让出CPU Thread.yield(); // lost initialization race; just spin else if (U.compareAndSwapInt(this, SIZECTL, sc, -1)) &#123; try &#123; if ((tab = table) == null || tab.length == 0) &#123; int n = (sc &gt; 0) ? sc : DEFAULT_CAPACITY; @SuppressWarnings("unchecked") Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n]; table = tab = nt; //n-(n&gt;&gt;&gt;2)=n-n/4=0.75n 可见ConcurrentHashMap的loadFactor是固定的0.75 sc = n - (n &gt;&gt;&gt; 2); &#125; &#125; finally &#123; //将sc赋值给sizeCtl 存储了下一次扩容的门槛 sizeCtl = sc; &#125; break; &#125; &#125; return tab;&#125;相较于HashMap，ConcurrentHashMap移除了`threshold`和`loadFactor`,使用`sizeCtl`来进行控制 而且只存储了容量，其具体控制逻辑如下：- -1表示有线程正在进行初始化操作- -(1 + nThreads)表示n个线程正在一起扩容- 0 默认值 后续再正在初始化时使用默认容量- `&gt;0` 初始化或扩容后下一次的扩容门槛通过`initTable()`初始化桶数组的代码可知：1. 通过CAS操作 保证只有一个线程初始化操作2. sizeCtl在初始化后是下一次扩容的门槛3. 容量因子是写死的0.75 判断是否需要扩容每添加一个元素后 元素数量加1 并判断是否达到扩容门槛 达到则进行扩容或协助扩容12345678910111213141516171819202122232425262728293031323334353637private final void addCount(long x, int check) &#123; CounterCell[] as; long b, s; if ((as = counterCells) != null || !U.compareAndSwapLong(this, BASECOUNT, b = baseCount, s = b + x)) &#123; CounterCell a; long v; int m; boolean uncontended = true; if (as == null || (m = as.length - 1) &lt; 0 || (a = as[ThreadLocalRandom.getProbe() &amp; m]) == null || !(uncontended = U.compareAndSwapLong(a, CELLVALUE, v = a.value, v + x))) &#123; fullAddCount(x, uncontended); return; &#125; if (check &lt;= 1) return; s = sumCount(); &#125; if (check &gt;= 0) &#123; Node&lt;K,V&gt;[] tab, nt; int n, sc; while (s &gt;= (long)(sc = sizeCtl) &amp;&amp; (tab = table) != null &amp;&amp; (n = tab.length) &lt; MAXIMUM_CAPACITY) &#123; int rs = resizeStamp(n); if (sc &lt; 0) &#123; if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || (nt = nextTable) == null || transferIndex &lt;= 0) break; if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) transfer(tab, nt); &#125; else if (U.compareAndSwapInt(this, SIZECTL, sc, (rs &lt;&lt; RESIZE_STAMP_SHIFT) + 2)) transfer(tab, null); s = sumCount(); &#125; &#125;&#125; 协助扩容12345678910111213141516171819final Node&lt;K,V&gt;[] helpTransfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt; f) &#123; Node&lt;K,V&gt;[] nextTab; int sc; if (tab != null &amp;&amp; (f instanceof ForwardingNode) &amp;&amp; (nextTab = ((ForwardingNode&lt;K,V&gt;)f).nextTable) != null) &#123; int rs = resizeStamp(tab.length); while (nextTab == nextTable &amp;&amp; table == tab &amp;&amp; (sc = sizeCtl) &lt; 0) &#123; if ((sc &gt;&gt;&gt; RESIZE_STAMP_SHIFT) != rs || sc == rs + 1 || sc == rs + MAX_RESIZERS || transferIndex &lt;= 0) break; if (U.compareAndSwapInt(this, SIZECTL, sc, sc + 1)) &#123; transfer(tab, nextTab); break; &#125; &#125; return nextTab; &#125; return table;&#125; 迁移元素123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132private final void transfer(Node&lt;K,V&gt;[] tab, Node&lt;K,V&gt;[] nextTab) &#123; int n = tab.length, stride; if ((stride = (NCPU &gt; 1) ? (n &gt;&gt;&gt; 3) / NCPU : n) &lt; MIN_TRANSFER_STRIDE) stride = MIN_TRANSFER_STRIDE; // subdivide range if (nextTab == null) &#123; // initiating try &#123; @SuppressWarnings("unchecked") Node&lt;K,V&gt;[] nt = (Node&lt;K,V&gt;[])new Node&lt;?,?&gt;[n &lt;&lt; 1]; nextTab = nt; &#125; catch (Throwable ex) &#123; // try to cope with OOME sizeCtl = Integer.MAX_VALUE; return; &#125; nextTable = nextTab; transferIndex = n; &#125; int nextn = nextTab.length; ForwardingNode&lt;K,V&gt; fwd = new ForwardingNode&lt;K,V&gt;(nextTab); boolean advance = true; boolean finishing = false; // to ensure sweep before committing nextTab for (int i = 0, bound = 0;;) &#123; Node&lt;K,V&gt; f; int fh; while (advance) &#123; int nextIndex, nextBound; if (--i &gt;= bound || finishing) advance = false; else if ((nextIndex = transferIndex) &lt;= 0) &#123; i = -1; advance = false; &#125; else if (U.compareAndSwapInt (this, TRANSFERINDEX, nextIndex, nextBound = (nextIndex &gt; stride ? nextIndex - stride : 0))) &#123; bound = nextBound; i = nextIndex - 1; advance = false; &#125; &#125; if (i &lt; 0 || i &gt;= n || i + n &gt;= nextn) &#123; int sc; if (finishing) &#123; nextTable = null; table = nextTab; sizeCtl = (n &lt;&lt; 1) - (n &gt;&gt;&gt; 1); return; &#125; if (U.compareAndSwapInt(this, SIZECTL, sc = sizeCtl, sc - 1)) &#123; if ((sc - 2) != resizeStamp(n) &lt;&lt; RESIZE_STAMP_SHIFT) return; finishing = advance = true; i = n; // recheck before commit &#125; &#125; else if ((f = tabAt(tab, i)) == null) advance = casTabAt(tab, i, null, fwd); else if ((fh = f.hash) == MOVED) advance = true; // already processed else &#123; synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; Node&lt;K,V&gt; ln, hn; if (fh &gt;= 0) &#123; int runBit = fh &amp; n; Node&lt;K,V&gt; lastRun = f; for (Node&lt;K,V&gt; p = f.next; p != null; p = p.next) &#123; int b = p.hash &amp; n; if (b != runBit) &#123; runBit = b; lastRun = p; &#125; &#125; if (runBit == 0) &#123; ln = lastRun; hn = null; &#125; else &#123; hn = lastRun; ln = null; &#125; for (Node&lt;K,V&gt; p = f; p != lastRun; p = p.next) &#123; int ph = p.hash; K pk = p.key; V pv = p.val; if ((ph &amp; n) == 0) ln = new Node&lt;K,V&gt;(ph, pk, pv, ln); else hn = new Node&lt;K,V&gt;(ph, pk, pv, hn); &#125; setTabAt(nextTab, i, ln); setTabAt(nextTab, i + n, hn); setTabAt(tab, i, fwd); advance = true; &#125; else if (f instanceof TreeBin) &#123; TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f; TreeNode&lt;K,V&gt; lo = null, loTail = null; TreeNode&lt;K,V&gt; hi = null, hiTail = null; int lc = 0, hc = 0; for (Node&lt;K,V&gt; e = t.first; e != null; e = e.next) &#123; int h = e.hash; TreeNode&lt;K,V&gt; p = new TreeNode&lt;K,V&gt; (h, e.key, e.val, null, null); if ((h &amp; n) == 0) &#123; if ((p.prev = loTail) == null) lo = p; else loTail.next = p; loTail = p; ++lc; &#125; else &#123; if ((p.prev = hiTail) == null) hi = p; else hiTail.next = p; hiTail = p; ++hc; &#125; &#125; ln = (lc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(lo) : (hc != 0) ? new TreeBin&lt;K,V&gt;(lo) : t; hn = (hc &lt;= UNTREEIFY_THRESHOLD) ? untreeify(hi) : (lc != 0) ? new TreeBin&lt;K,V&gt;(hi) : t; setTabAt(nextTab, i, ln); setTabAt(nextTab, i + n, hn); setTabAt(tab, i, fwd); advance = true; &#125; &#125; &#125; &#125; &#125;&#125; 删除元素12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273public V remove(Object key) &#123; return replaceNode(key, null, null);&#125;final V replaceNode(Object key, V value, Object cv) &#123; int hash = spread(key.hashCode()); for (Node&lt;K,V&gt;[] tab = table;;) &#123; Node&lt;K,V&gt; f; int n, i, fh; if (tab == null || (n = tab.length) == 0 || (f = tabAt(tab, i = (n - 1) &amp; hash)) == null) break; else if ((fh = f.hash) == MOVED) tab = helpTransfer(tab, f); else &#123; V oldVal = null; boolean validated = false; synchronized (f) &#123; if (tabAt(tab, i) == f) &#123; if (fh &gt;= 0) &#123; validated = true; for (Node&lt;K,V&gt; e = f, pred = null;;) &#123; K ek; if (e.hash == hash &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) &#123; V ev = e.val; if (cv == null || cv == ev || (ev != null &amp;&amp; cv.equals(ev))) &#123; oldVal = ev; if (value != null) e.val = value; else if (pred != null) pred.next = e.next; else setTabAt(tab, i, e.next); &#125; break; &#125; pred = e; if ((e = e.next) == null) break; &#125; &#125; else if (f instanceof TreeBin) &#123; validated = true; TreeBin&lt;K,V&gt; t = (TreeBin&lt;K,V&gt;)f; TreeNode&lt;K,V&gt; r, p; if ((r = t.root) != null &amp;&amp; (p = r.findTreeNode(hash, key, null)) != null) &#123; V pv = p.val; if (cv == null || cv == pv || (pv != null &amp;&amp; cv.equals(pv))) &#123; oldVal = pv; if (value != null) p.val = value; else if (t.removeTreeNode(p)) setTabAt(tab, i, untreeify(t.first)); &#125; &#125; &#125; &#125; &#125; if (validated) &#123; if (oldVal != null) &#123; if (value == null) addCount(-1L, -1); return oldVal; &#125; break; &#125; &#125; &#125; return null;&#125; 获取元素12345678910111213141516171819public V get(Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; e, p; int n, eh; K ek; int h = spread(key.hashCode()); if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (e = tabAt(tab, (n - 1) &amp; h)) != null) &#123; if ((eh = e.hash) == h) &#123; if ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek))) return e.val; &#125; else if (eh &lt; 0) return (p = e.find(h, key)) != null ? p.val : null; while ((e = e.next) != null) &#123; if (e.hash == h &amp;&amp; ((ek = e.key) == key || (ek != null &amp;&amp; key.equals(ek)))) return e.val; &#125; &#125; return null;&#125; 获取元素个数1234567891011121314151617public int size() &#123; long n = sumCount(); return ((n &lt; 0L) ? 0 : (n &gt; (long)Integer.MAX_VALUE) ? Integer.MAX_VALUE : (int)n);&#125;final long sumCount() &#123; CounterCell[] as = counterCells; CounterCell a; long sum = baseCount; if (as != null) &#123; for (int i = 0; i &lt; as.length; ++i) &#123; if ((a = as[i]) != null) sum += a.value; &#125; &#125; return sum;&#125; 总结ConcurrentHashMap使用到的技术点： CAS+自旋 乐观锁的思想减少线程上下文切换 分段锁的思想 减少同一把锁争用带来的低效问题 CounterCell 分段存储元素个数 减少多线程同时更新一个字段带来的低效 @sun.misc.Contended(CounterCell上的注解) 避免伪共享 多线程协同进行扩容]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConcurrentSkipListMap]]></title>
    <url>%2FJava%E9%9B%86%E5%90%88%2FConcurrentSkipListMap%2F</url>
    <content type="text"><![CDATA[ConcurrentSkipListMap是基于跳表实现，跳表是一个随机化的数据结构，实质是一种可以进行二分查找的有序链表。跳表在原有的有序链表上面增加了多级索引，通过索引来实现快速查找。调表不仅能提高搜索性能，同时也能提高插入和删除操作的性能。 其继承关系如下： 主要属性1234567891011121314151617181920212223242526272829303132public class ConcurrentSkipListMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements ConcurrentNavigableMap&lt;K,V&gt;, Cloneable, Serializable &#123; private static final long serialVersionUID = -8627078645895051609L; /** * Special value used to identify base-level header */ private static final Object BASE_HEADER = new Object(); /** * The topmost head index of the skiplist. */ private transient volatile HeadIndex&lt;K,V&gt; head; /** * The comparator used to maintain order in this map, or null if * using natural ordering. (Non-private to simplify access in * nested classes.) * @serial */ final Comparator&lt;? super K&gt; comparator; /** Lazily initialized key set */ private transient KeySet&lt;K&gt; keySet; /** Lazily initialized entry set */ private transient EntrySet&lt;K,V&gt; entrySet; /** Lazily initialized values collection */ private transient Values&lt;V&gt; values; /** Lazily initialized descending key set */ private transient ConcurrentNavigableMap&lt;K,V&gt; descendingMap; ... ...&#125; 内部类12345678910111213141516171819202122232425262728293031323334353637383940//数据节点static final class Node&lt;K,V&gt; &#123; final K key; volatile Object value; volatile Node&lt;K,V&gt; next; /** * Creates a new regular node. */ Node(K key, Object value, Node&lt;K,V&gt; next) &#123; this.key = key; this.value = value; this.next = next; &#125; ... ... &#125;//索引节点static class Index&lt;K,V&gt; &#123; final Node&lt;K,V&gt; node; final Index&lt;K,V&gt; down; volatile Index&lt;K,V&gt; right; /** * Creates index node with given values. */ Index(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right) &#123; this.node = node; this.down = down; this.right = right; &#125; ... ...&#125;//头索引节点 继承自Index 扩展一个level字段 记录索引的层级static final class HeadIndex&lt;K,V&gt; extends Index&lt;K,V&gt; &#123; final int level; HeadIndex(Node&lt;K,V&gt; node, Index&lt;K,V&gt; down, Index&lt;K,V&gt; right, int level) &#123; super(node, down, right); this.level = level; &#125;&#125; 构造器123456789101112131415161718192021public ConcurrentSkipListMap() &#123; this.comparator = null; initialize();&#125;public ConcurrentSkipListMap(Comparator&lt;? super K&gt; comparator) &#123; this.comparator = comparator; initialize();&#125;public ConcurrentSkipListMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.comparator = null; initialize(); putAll(m);&#125;public ConcurrentSkipListMap(SortedMap&lt;K, ? extends V&gt; m) &#123; this.comparator = m.comparator(); initialize(); buildFromSorted(m);&#125; initialize()1234567private void initialize() &#123; keySet = null; entrySet = null; values = null; descendingMap = null; head = new HeadIndex&lt;K,V&gt;(new Node&lt;K,V&gt;(null, BASE_HEADER, null), null, null, 1);&#125; 添加元素123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177public V put(K key, V value) &#123; if (value == null) throw new NullPointerException(); return doPut(key, value, false);&#125;private V doPut(K key, V value, boolean onlyIfAbsent) &#123; Node&lt;K,V&gt; z; // added node if (key == null) throw new NullPointerException(); Comparator&lt;? super K&gt; cmp = comparator; outer: for (;;) &#123; for (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123; if (n != null) &#123; Object v; int c; Node&lt;K,V&gt; f = n.next; if (n != b.next) // inconsistent read break; if ((v = n.value) == null) &#123; // n is deleted n.helpDelete(b, f); break; &#125; if (b.value == null || v == n) // b is deleted break; if ((c = cpr(cmp, key, n.key)) &gt; 0) &#123; b = n; n = f; continue; &#125; if (c == 0) &#123; if (onlyIfAbsent || n.casValue(v, value)) &#123; @SuppressWarnings("unchecked") V vv = (V)v; return vv; &#125; break; // restart if lost race to replace value &#125; // else c &lt; 0; fall through &#125; z = new Node&lt;K,V&gt;(key, value, n); if (!b.casNext(n, z)) break; // restart if lost race to append to b break outer; &#125; &#125; int rnd = ThreadLocalRandom.nextSecondarySeed(); if ((rnd &amp; 0x80000001) == 0) &#123; // test highest and lowest bits int level = 1, max; while (((rnd &gt;&gt;&gt;= 1) &amp; 1) != 0) ++level; Index&lt;K,V&gt; idx = null; HeadIndex&lt;K,V&gt; h = head; if (level &lt;= (max = h.level)) &#123; for (int i = 1; i &lt;= level; ++i) idx = new Index&lt;K,V&gt;(z, idx, null); &#125; else &#123; // try to grow by one level level = max + 1; // hold in array and later pick the one to use @SuppressWarnings("unchecked")Index&lt;K,V&gt;[] idxs = (Index&lt;K,V&gt;[])new Index&lt;?,?&gt;[level+1]; for (int i = 1; i &lt;= level; ++i) idxs[i] = idx = new Index&lt;K,V&gt;(z, idx, null); for (;;) &#123; h = head; int oldLevel = h.level; if (level &lt;= oldLevel) // lost race to add level break; HeadIndex&lt;K,V&gt; newh = h; Node&lt;K,V&gt; oldbase = h.node; for (int j = oldLevel+1; j &lt;= level; ++j) newh = new HeadIndex&lt;K,V&gt;(oldbase, newh, idxs[j], j); if (casHead(h, newh)) &#123; h = newh; idx = idxs[level = oldLevel]; break; &#125; &#125; &#125; // find insertion points and splice in splice: for (int insertionLevel = level;;) &#123; int j = h.level; for (Index&lt;K,V&gt; q = h, r = q.right, t = idx;;) &#123; if (q == null || t == null) break splice; if (r != null) &#123; Node&lt;K,V&gt; n = r.node; // compare before deletion check avoids needing recheck int c = cpr(cmp, key, n.key); if (n.value == null) &#123; if (!q.unlink(r)) break; r = q.right; continue; &#125; if (c &gt; 0) &#123; q = r; r = r.right; continue; &#125; &#125; if (j == insertionLevel) &#123; if (!q.link(r, t)) break; // restart if (t.node.value == null) &#123; findNode(key); break splice; &#125; if (--insertionLevel == 0) break splice; &#125; if (--j &gt;= insertionLevel &amp;&amp; j &lt; level) t = t.down; q = q.down; r = q.right; &#125; &#125; &#125; return null;&#125;private Node&lt;K,V&gt; findPredecessor(Object key, Comparator&lt;? super K&gt; cmp) &#123; if (key == null) throw new NullPointerException(); // don't postpone errors for (;;) &#123; for (Index&lt;K,V&gt; q = head, r = q.right, d;;) &#123; if (r != null) &#123; Node&lt;K,V&gt; n = r.node; K k = n.key; if (n.value == null) &#123; if (!q.unlink(r)) break; // restart r = q.right; // reread r continue; &#125; if (cpr(cmp, key, k) &gt; 0) &#123; q = r; r = r.right; continue; &#125; &#125; if ((d = q.down) == null) return q.node; q = d; r = d.right; &#125; &#125;&#125;void helpDelete(Node&lt;K,V&gt; b, Node&lt;K,V&gt; f) &#123; /* * Rechecking links and then doing only one of the * help-out stages per call tends to minimize CAS * interference among helping threads. */ if (f == next &amp;&amp; this == b.next) &#123; if (f == null || f.value != f) // not already marked casNext(f, new Node&lt;K,V&gt;(f)); else b.casNext(this, f.next); &#125;&#125;final boolean unlink(Index&lt;K,V&gt; succ) &#123; return node.value != null &amp;&amp; casRight(succ, succ.right);&#125;final boolean link(Index&lt;K,V&gt; succ, Index&lt;K,V&gt; newSucc) &#123; Node&lt;K,V&gt; n = node; newSucc.right = succ; return n.value != null &amp;&amp; casRight(succ, newSucc);&#125; 删除元素12345678910111213141516171819202122232425262728293031323334353637383940414243444546public V remove(Object key) &#123; return doRemove(key, null);&#125;final V doRemove(Object key, Object value) &#123; if (key == null) throw new NullPointerException(); Comparator&lt;? super K&gt; cmp = comparator; outer: for (;;) &#123; for (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123; Object v; int c; if (n == null) break outer; Node&lt;K,V&gt; f = n.next; if (n != b.next) // inconsistent read break; if ((v = n.value) == null) &#123; // n is deleted n.helpDelete(b, f); break; &#125; if (b.value == null || v == n) // b is deleted break; if ((c = cpr(cmp, key, n.key)) &lt; 0) break outer; if (c &gt; 0) &#123; b = n; n = f; continue; &#125; if (value != null &amp;&amp; !value.equals(v)) break outer; if (!n.casValue(v, null)) break; if (!n.appendMarker(f) || !b.casNext(n, f)) findNode(key); // retry via findNode else &#123; findPredecessor(key, cmp); // clean index if (head.right == null) tryReduceLevel(); &#125; @SuppressWarnings("unchecked") V vv = (V)v; return vv; &#125; &#125; return null;&#125; 查找元素123456789101112131415161718192021222324252627282930313233public V get(Object key) &#123; return doGet(key);&#125;private V doGet(Object key) &#123; if (key == null) throw new NullPointerException(); Comparator&lt;? super K&gt; cmp = comparator; outer: for (;;) &#123; for (Node&lt;K,V&gt; b = findPredecessor(key, cmp), n = b.next;;) &#123; Object v; int c; if (n == null) break outer; Node&lt;K,V&gt; f = n.next; if (n != b.next) // inconsistent read break; if ((v = n.value) == null) &#123; // n is deleted n.helpDelete(b, f); break; &#125; if (b.value == null || v == n) // b is deleted break; if ((c = cpr(cmp, key, n.key)) == 0) &#123; @SuppressWarnings("unchecked") V vv = (V)v; return vv; &#125; if (c &lt; 0) break outer; b = n; n = f; &#125; &#125; return null;&#125;]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[TreeMap]]></title>
    <url>%2FJava%E9%9B%86%E5%90%88%2FTreeMap%2F</url>
    <content type="text"><![CDATA[TreeMap使用红黑树存储元素，可以保证元素按照key值的大小进行遍历。 其继承关系如下： TreeMap实现了Map、SortedMap、NavigableMap、Cloneable、Serializable等接口SortedMap规定了元素可以按key大小来遍历，定义了获取部分map的方法：123456789101112131415161718//key的比较器Comparator&lt;? super K&gt; comparator();SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey);SortedMap&lt;K,V&gt; headMap(K toKey);SortedMap&lt;K,V&gt; tailMap(K fromKey);K firstKey();K lastKey();Set&lt;K&gt; keySet();Collection&lt;V&gt; values();Set&lt;Map.Entry&lt;K, V&gt;&gt; entrySet();NavigableMap是对SortedMap的增强，定义了获取离目标key最近的元素的方法：1234567891011121314151617181920212223242526272829303132333435363738394041Map.Entry&lt;K,V&gt; lowerEntry(K key);K lowerKey(K key);Map.Entry&lt;K,V&gt; floorEntry(K key);K floorKey(K key);Map.Entry&lt;K,V&gt; ceilingEntry(K key);K ceilingKey(K key);Map.Entry&lt;K,V&gt; higherEntry(K key);K higherKey(K key);Map.Entry&lt;K,V&gt; firstEntry();Map.Entry&lt;K,V&gt; lastEntry();Map.Entry&lt;K,V&gt; pollFirstEntry();Map.Entry&lt;K,V&gt; pollLastEntry();NavigableMap&lt;K,V&gt; descendingMap();NavigableSet&lt;K&gt; navigableKeySet();NavigableSet&lt;K&gt; descendingKeySet();NavigableMap&lt;K,V&gt; subMap(K fromKey, boolean fromInclusive, K toKey, boolean toInclusive); NavigableMap&lt;K,V&gt; headMap(K toKey, boolean inclusive);NavigableMap&lt;K,V&gt; tailMap(K fromKey, boolean inclusive);SortedMap&lt;K,V&gt; subMap(K fromKey, K toKey);SortedMap&lt;K,V&gt; headMap(K toKey);SortedMap&lt;K,V&gt; tailMap(K fromKey); TreeMap只使用到了红黑树，故它的时间复杂度为O(logn) 回顾下红黑树的特性： 每个节点 红色或者黑色 根节点是黑色 每个叶子节点是黑色（这里的叶子节点是空节点） 若一个节点是红色 则它的叶子节点必须是黑色 从一个节点到该节点的子孙节点的所有路径上包含相同数目的黑节点 主要属性1234567891011121314151617public class TreeMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements NavigableMap&lt;K,V&gt;, Cloneable, java.io.Serializable&#123; //比较器 private final Comparator&lt;? super K&gt; comparator; //根节点 private transient Entry&lt;K,V&gt; root; //元素个数 private transient int size = 0; //修改次数 private transient int modCount = 0; ... ... &#125; comparator可以通过构造器传入 或者key实现comparable接口 内部类12345678910111213141516171819static final class Entry&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; K key; V value; Entry&lt;K,V&gt; left; Entry&lt;K,V&gt; right; Entry&lt;K,V&gt; parent; boolean color = BLACK; /** * Make a new cell with given key, value, and parent, and with * &#123;@code null&#125; child links, and BLACK color. */ Entry(K key, V value, Entry&lt;K,V&gt; parent) &#123; this.key = key; this.value = value; this.parent = parent; &#125; ... ...&#125; 构造器123456789101112131415161718192021public TreeMap() &#123; comparator = null;&#125;public TreeMap(Comparator&lt;? super K&gt; comparator) &#123; this.comparator = comparator;&#125;public TreeMap(Map&lt;? extends K, ? extends V&gt; m) &#123; comparator = null; putAll(m);&#125;public TreeMap(SortedMap&lt;K, ? extends V&gt; m) &#123; comparator = m.comparator(); try &#123; buildFromSorted(m.size(), m.entrySet().iterator(), null, null); &#125; catch (java.io.IOException cannotHappen) &#123; &#125; catch (ClassNotFoundException cannotHappen) &#123; &#125;&#125; getObject(Object key)123456789101112131415161718192021222324252627282930313233343536373839404142public V get(Object key) &#123; Entry&lt;K,V&gt; p = getEntry(key); return (p==null ? null : p.value);&#125;final Entry&lt;K,V&gt; getEntry(Object key) &#123; // Offload comparator-based version for sake of performance if (comparator != null) return getEntryUsingComparator(key); if (key == null) throw new NullPointerException(); @SuppressWarnings("unchecked") Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = k.compareTo(p.key); if (cmp &lt; 0) p = p.left; else if (cmp &gt; 0) p = p.right; else return p; &#125; return null;&#125;final Entry&lt;K,V&gt; getEntryUsingComparator(Object key) &#123; @SuppressWarnings("unchecked") K k = (K) key; Comparator&lt;? super K&gt; cpr = comparator; if (cpr != null) &#123; Entry&lt;K,V&gt; p = root; while (p != null) &#123; int cmp = cpr.compare(k, p.key); if (cmp &lt; 0) p = p.left; else if (cmp &gt; 0) p = p.right; else return p; &#125; &#125; return null;&#125; 左旋123456789101112131415161718/** From CLR */private void rotateLeft(Entry&lt;K,V&gt; p) &#123; if (p != null) &#123; Entry&lt;K,V&gt; r = p.right; p.right = r.left; if (r.left != null) r.left.parent = p; r.parent = p.parent; if (p.parent == null) root = r; else if (p.parent.left == p) p.parent.left = r; else p.parent.right = r; r.left = p; p.parent = r; &#125;&#125; 右旋12345678910111213141516/** From CLR */private void rotateRight(Entry&lt;K,V&gt; p) &#123; if (p != null) &#123; Entry&lt;K,V&gt; l = p.left; p.left = l.right; if (l.right != null) l.right.parent = p; l.parent = p.parent; if (p.parent == null) root = l; else if (p.parent.right == p) p.parent.right = l; else p.parent.left = l; l.right = p; p.parent = l; &#125;&#125; 插入元素123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051public V put(K key, V value) &#123; Entry&lt;K,V&gt; t = root; if (t == null) &#123; compare(key, key); // type (and possibly null) check root = new Entry&lt;&gt;(key, value, null); size = 1; modCount++; return null; &#125; int cmp; Entry&lt;K,V&gt; parent; // split comparator and comparable paths Comparator&lt;? super K&gt; cpr = comparator; if (cpr != null) &#123; do &#123; parent = t; cmp = cpr.compare(key, t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; else &#123; if (key == null) throw new NullPointerException(); @SuppressWarnings("unchecked") Comparable&lt;? super K&gt; k = (Comparable&lt;? super K&gt;) key; do &#123; parent = t; cmp = k.compareTo(t.key); if (cmp &lt; 0) t = t.left; else if (cmp &gt; 0) t = t.right; else return t.setValue(value); &#125; while (t != null); &#125; Entry&lt;K,V&gt; e = new Entry&lt;&gt;(key, value, parent); if (cmp &lt; 0) parent.left = e; else parent.right = e; fixAfterInsertion(e); size++; modCount++; return null;&#125; 插入再平衡12345678910111213141516171819202122232425262728293031323334353637383940private void fixAfterInsertion(Entry&lt;K,V&gt; x) &#123; x.color = RED; while (x != null &amp;&amp; x != root &amp;&amp; x.parent.color == RED) &#123; if (parentOf(x) == leftOf(parentOf(parentOf(x)))) &#123; Entry&lt;K,V&gt; y = rightOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); &#125; else &#123; if (x == rightOf(parentOf(x))) &#123; x = parentOf(x); rotateLeft(x); &#125; setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateRight(parentOf(parentOf(x))); &#125; &#125; else &#123; Entry&lt;K,V&gt; y = leftOf(parentOf(parentOf(x))); if (colorOf(y) == RED) &#123; setColor(parentOf(x), BLACK); setColor(y, BLACK); setColor(parentOf(parentOf(x)), RED); x = parentOf(parentOf(x)); &#125; else &#123; if (x == leftOf(parentOf(x))) &#123; x = parentOf(x); rotateRight(x); &#125; setColor(parentOf(x), BLACK); setColor(parentOf(parentOf(x)), RED); rotateLeft(parentOf(parentOf(x))); &#125; &#125; &#125; root.color = BLACK;&#125; 删除元素123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657public V remove(Object key) &#123; Entry&lt;K,V&gt; p = getEntry(key); if (p == null) return null; V oldValue = p.value; deleteEntry(p); return oldValue;&#125;private void deleteEntry(Entry&lt;K,V&gt; p) &#123; modCount++; size--; // If strictly internal, copy successor's element to p and then make p // point to successor. if (p.left != null &amp;&amp; p.right != null) &#123; Entry&lt;K,V&gt; s = successor(p); p.key = s.key; p.value = s.value; p = s; &#125; // p has 2 children // Start fixup at replacement node, if it exists. Entry&lt;K,V&gt; replacement = (p.left != null ? p.left : p.right); if (replacement != null) &#123; // Link replacement to parent replacement.parent = p.parent; if (p.parent == null) root = replacement; else if (p == p.parent.left) p.parent.left = replacement; else p.parent.right = replacement; // Null out links so they are OK to use by fixAfterDeletion. p.left = p.right = p.parent = null; // Fix replacement if (p.color == BLACK) fixAfterDeletion(replacement); &#125; else if (p.parent == null) &#123; // return if we are the only node. root = null; &#125; else &#123; // No children. Use self as phantom replacement and unlink. if (p.color == BLACK) fixAfterDeletion(p); if (p.parent != null) &#123; if (p == p.parent.left) p.parent.left = null; else if (p == p.parent.right) p.parent.right = null; p.parent = null; &#125; &#125;&#125; 删除再平衡12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061private void fixAfterDeletion(Entry&lt;K,V&gt; x) &#123; while (x != root &amp;&amp; colorOf(x) == BLACK) &#123; if (x == leftOf(parentOf(x))) &#123; Entry&lt;K,V&gt; sib = rightOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); setColor(parentOf(x), RED); rotateLeft(parentOf(x)); sib = rightOf(parentOf(x)); &#125; if (colorOf(leftOf(sib)) == BLACK &amp;&amp; colorOf(rightOf(sib)) == BLACK) &#123; setColor(sib, RED); x = parentOf(x); &#125; else &#123; if (colorOf(rightOf(sib)) == BLACK) &#123; setColor(leftOf(sib), BLACK); setColor(sib, RED); rotateRight(sib); sib = rightOf(parentOf(x)); &#125; setColor(sib, colorOf(parentOf(x))); setColor(parentOf(x), BLACK); setColor(rightOf(sib), BLACK); rotateLeft(parentOf(x)); x = root; &#125; &#125; else &#123; // symmetric Entry&lt;K,V&gt; sib = leftOf(parentOf(x)); if (colorOf(sib) == RED) &#123; setColor(sib, BLACK); setColor(parentOf(x), RED); rotateRight(parentOf(x)); sib = leftOf(parentOf(x)); &#125; if (colorOf(rightOf(sib)) == BLACK &amp;&amp; colorOf(leftOf(sib)) == BLACK) &#123; setColor(sib, RED); x = parentOf(x); &#125; else &#123; if (colorOf(leftOf(sib)) == BLACK) &#123; setColor(rightOf(sib), BLACK); setColor(sib, RED); rotateLeft(sib); sib = leftOf(parentOf(x)); &#125; setColor(sib, colorOf(parentOf(x))); setColor(parentOf(x), BLACK); setColor(leftOf(sib), BLACK); rotateRight(parentOf(x)); x = root; &#125; &#125; &#125; setColor(x, BLACK);&#125; 总结]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WeakHashMap]]></title>
    <url>%2FJava%E9%9B%86%E5%90%88%2FWeakHashMap%2F</url>
    <content type="text"><![CDATA[WeakHashMap是一种弱引用map，内部key会存储为弱引用，当JVM GC时 若这些key没有强引用存在时就会被gc回收，下次当我们操作map时会将对应的Entry这个删除掉，基于这个特性，WeakHashMap特别适合做缓存。其继承关系如下： 主要属性1234567891011121314151617181920212223public class WeakHashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt; &#123; //初始化容量为16 private static final int DEFAULT_INITIAL_CAPACITY = 16; //最大容量为2的30次方 private static final int MAXIMUM_CAPACITY = 1 &lt;&lt; 30; //默认装载因子 private static final float DEFAULT_LOAD_FACTOR = 0.75f; //桶 Entry&lt;K,V&gt;[] table; //元素个数 private int size; //扩容阈值 threshold=capacity*loadFactor private int threshold; //装载因子 private final float loadFactor; //引用队列 当弱引用键失效时会把Entry添加到这个队列中 private final ReferenceQueue&lt;Object&gt; queue = new ReferenceQueue&lt;&gt;(); //修改次数 用于遍历过程中判断快速失败 int modCount; ... ... &#125; 构造器123456789101112131415161718192021222324252627282930public WeakHashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal Initial Capacity: "+ initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal Load factor: "+ loadFactor); int capacity = 1; while (capacity &lt; initialCapacity) capacity &lt;&lt;= 1; table = newTable(capacity); this.loadFactor = loadFactor; threshold = (int)(capacity * loadFactor);&#125;public WeakHashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;public WeakHashMap() &#123; this(DEFAULT_INITIAL_CAPACITY, DEFAULT_LOAD_FACTOR);&#125;public WeakHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this(Math.max((int) (m.size() / DEFAULT_LOAD_FACTOR) + 1, DEFAULT_INITIAL_CAPACITY), DEFAULT_LOAD_FACTOR); putAll(m);&#125; 内部类123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778private static class Entry&lt;K,V&gt; extends WeakReference&lt;Object&gt; implements Map.Entry&lt;K,V&gt; &#123; //这里并没有定义Key 因为key是作为弱引用存到Reference类中 V value; final int hash; Entry&lt;K,V&gt; next; /** * Creates new entry. */ Entry(Object key, V value, ReferenceQueue&lt;Object&gt; queue, int hash, Entry&lt;K,V&gt; next) &#123; super(key, queue); this.value = value; this.hash = hash; this.next = next; &#125; @SuppressWarnings("unchecked") public K getKey() &#123; return (K) WeakHashMap.unmaskNull(get()); &#125; ... ...&#125;public class WeakReference&lt;T&gt; extends Reference&lt;T&gt; &#123; /** * Creates a new weak reference that refers to the given object. The new * reference is not registered with any queue. * * @param referent object the new weak reference will refer to */ public WeakReference(T referent) &#123; super(referent); &#125; /** * Creates a new weak reference that refers to the given object and is * registered with the given queue. * * @param referent object the new weak reference will refer to * @param q the queue with which the reference is to be registered, * or &lt;tt&gt;null&lt;/tt&gt; if registration is not required */ public WeakReference(T referent, ReferenceQueue&lt;? super T&gt; q) &#123; super(referent, q); &#125;&#125;public abstract class Reference&lt;T&gt; &#123; //存储key的地方 private T referent; /* Treated specially by GC */ //引用队列 volatile ReferenceQueue&lt;? super T&gt; queue; /* When active: NULL * pending: this * Enqueued: next reference in queue (or this if last) * Inactive: this */ @SuppressWarnings("rawtypes") Reference next; /* When active: next element in a discovered reference list maintained by GC (or this if last) * pending: next element in the pending list (or null if last) * otherwise: NULL */ transient private Reference&lt;T&gt; discovered; Reference(T referent) &#123; this(referent, null); &#125; Reference(T referent, ReferenceQueue&lt;? super T&gt; queue) &#123; this.referent = referent; this.queue = (queue == null) ? ReferenceQueue.NULL : queue; &#125; put(K key,V value)12345678910111213141516171819202122232425public V put(K key, V value) &#123; Object k = maskNull(key); int h = hash(k); Entry&lt;K,V&gt;[] tab = getTable(); int i = indexFor(h, tab.length); for (Entry&lt;K,V&gt; e = tab[i]; e != null; e = e.next) &#123; if (h == e.hash &amp;&amp; eq(k, e.get())) &#123; V oldValue = e.value; if (value != oldValue) e.value = value; return oldValue; &#125; &#125; modCount++; Entry&lt;K,V&gt; e = tab[i]; tab[i] = new Entry&lt;&gt;(k, value, queue, h, e); if (++size &gt;= threshold) resize(tab.length * 2); return null;&#125;private static int indexFor(int h, int length) &#123; return h &amp; (length-1);&#125; resize(int newCapacity)123456789101112131415161718192021222324252627282930313233343536373839404142434445void resize(int newCapacity) &#123; Entry&lt;K,V&gt;[] oldTable = getTable(); int oldCapacity = oldTable.length; if (oldCapacity == MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return; &#125; Entry&lt;K,V&gt;[] newTable = newTable(newCapacity); transfer(oldTable, newTable); table = newTable; /* * If ignoring null elements and processing ref queue caused massive * shrinkage, then restore old table. This should be rare, but avoids * unbounded expansion of garbage-filled tables. */ if (size &gt;= threshold / 2) &#123; threshold = (int)(newCapacity * loadFactor); &#125; else &#123; expungeStaleEntries(); transfer(newTable, oldTable); table = oldTable; &#125;&#125;private void transfer(Entry&lt;K,V&gt;[] src, Entry&lt;K,V&gt;[] dest) &#123; for (int j = 0; j &lt; src.length; ++j) &#123; Entry&lt;K,V&gt; e = src[j]; src[j] = null; while (e != null) &#123; Entry&lt;K,V&gt; next = e.next; Object key = e.get(); if (key == null) &#123; e.next = null; // Help GC e.value = null; // " " size--; &#125; else &#123; int i = indexFor(e.hash, dest.length); e.next = dest[i]; dest[i] = e; &#125; e = next; &#125; &#125;&#125; get(Object key)12345678910111213public V get(Object key) &#123; Object k = maskNull(key); int h = hash(k); Entry&lt;K,V&gt;[] tab = getTable(); int index = indexFor(h, tab.length); Entry&lt;K,V&gt; e = tab[index]; while (e != null) &#123; if (e.hash == h &amp;&amp; eq(k, e.get())) return e.value; e = e.next; &#125; return null;&#125; remove(Object key)12345678910111213141516171819202122232425public V remove(Object key) &#123; Object k = maskNull(key); int h = hash(k); Entry&lt;K,V&gt;[] tab = getTable(); int i = indexFor(h, tab.length); Entry&lt;K,V&gt; prev = tab[i]; Entry&lt;K,V&gt; e = prev; while (e != null) &#123; Entry&lt;K,V&gt; next = e.next; if (h == e.hash &amp;&amp; eq(k, e.get())) &#123; modCount++; size--; if (prev == e) tab[i] = next; else prev.next = next; return e.value; &#125; prev = e; e = next; &#125; return null;&#125; expungeStaleEntries()删除失效的Entry1234567891011121314151617181920212223242526272829private void expungeStaleEntries() &#123; //当key失效时gc会自动将对应的Entry添加到引用队列queue中 for (Object x; (x = queue.poll()) != null; ) &#123; synchronized (queue) &#123; @SuppressWarnings("unchecked") Entry&lt;K,V&gt; e = (Entry&lt;K,V&gt;) x; int i = indexFor(e.hash, table.length); Entry&lt;K,V&gt; prev = table[i]; Entry&lt;K,V&gt; p = prev; while (p != null) &#123; Entry&lt;K,V&gt; next = p.next; if (p == e) &#123; if (prev == e) table[i] = next; else prev.next = next; // Must not null out e.next; // stale entries may be in use by a HashIterator e.value = null; // Help GC size--; break; &#125; prev = p; p = next; &#125; &#125; &#125;&#125; 总结]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedHashMap]]></title>
    <url>%2FJava%E9%9B%86%E5%90%88%2FLinkedHashMap%2F</url>
    <content type="text"><![CDATA[LinkedHashMap内部维护了一个双向链表，能够保证元素按插入顺序的访问，可以用来实现LRU缓存策略，可以看做是LinkedList+HashMap 其继承结构如下： LinkedHashMap继承了HashMap 拥有HashMap的所有特性，并额为添加了一个双向链表存储所有的元素顺序，添加、删除元素的时候要同时维护HashMap的存储数据和LinkedHashMap的双向链表的数据，故从性能上来说会比HashMap稍慢。 主要属性123456789101112131415161718192021public class LinkedHashMap&lt;K,V&gt; extends HashMap&lt;K,V&gt; implements Map&lt;K,V&gt;&#123;//双向链表节点结构static class Entry&lt;K,V&gt; extends HashMap.Node&lt;K,V&gt; &#123; Entry&lt;K,V&gt; before, after; Entry(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; super(hash, key, value, next); &#125;&#125;private static final long serialVersionUID = 3801124242820219131L;//双向链表头节点transient LinkedHashMap.Entry&lt;K,V&gt; head;//双向链表尾结点transient LinkedHashMap.Entry&lt;K,V&gt; tail;//是否按访问顺序排序final boolean accessOrder; ... ...&#125; 构造器123456789101112131415161718192021222324public LinkedHashMap(int initialCapacity, float loadFactor) &#123; super(initialCapacity, loadFactor); accessOrder = false;&#125;public LinkedHashMap(int initialCapacity) &#123; super(initialCapacity); accessOrder = false;&#125;public LinkedHashMap() &#123; super(); accessOrder = false;&#125;public LinkedHashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; super(); accessOrder = false; putMapEntries(m, false);&#125;public LinkedHashMap(int initialCapacity, float loadFactor, boolean accessOrder) &#123; super(initialCapacity, loadFactor); this.accessOrder = accessOrder;&#125; afterNodeInsertion(boolean evict)123456789101112131415161718192021222324252627282930313233343536373839404142434445464748void afterNodeInsertion(boolean evict) &#123; // possibly remove eldest LinkedHashMap.Entry&lt;K,V&gt; first; if (evict &amp;&amp; (first = head) != null &amp;&amp; removeEldestEntry(first)) &#123; K key = first.key; removeNode(hash(key), key, null, false, true); &#125;&#125;final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) &#123; if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; &#125; &#125; return null;&#125; afterNodeAccess(Node&lt;K,V&gt; e)123456789101112131415161718192021222324void afterNodeAccess(Node&lt;K,V&gt; e) &#123; // move node to last LinkedHashMap.Entry&lt;K,V&gt; last; if (accessOrder &amp;&amp; (last = tail) != e) &#123; LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.after = null; if (b == null) head = a; else b.after = a; if (a != null) a.before = b; else last = b; if (last == null) head = p; else &#123; p.before = last; last.after = p; &#125; tail = p; ++modCount; &#125;&#125; afterNodeRemoval(Node&lt;K,V&gt; e)12345678910111213void afterNodeRemoval(Node&lt;K,V&gt; e) &#123; // unlink LinkedHashMap.Entry&lt;K,V&gt; p = (LinkedHashMap.Entry&lt;K,V&gt;)e, b = p.before, a = p.after; p.before = p.after = null; if (b == null) head = a; else b.after = a; if (a == null) tail = b; else a.before = b;&#125; get(Object key)12345678public V get(Object key) &#123; Node&lt;K,V&gt; e; if ((e = getNode(hash(key), key)) == null) return null; if (accessOrder) afterNodeAccess(e); return e.value;&#125; 总结 LinkedHashMap继承自HashMap 具有HashMap的所有特性 LinkedHashMap内部维护了一个双向队列 若accessOrder为false 则按照插入元素的顺序遍历元素 若accessOrder为true 则按照访问元素的顺序遍历元素 LinkedHashMap可以用来实现LRU缓存淘汰策略 12345678910111213class LRU&lt;K, V&gt; extends LinkedHashMap&lt;K, V&gt; &#123; private int capacity; public LRU(int initialCapacity, float loadFactor, int capacity) &#123; super(initialCapacity, loadFactor, true); this.capacity = capacity; &#125; @Override protected boolean removeEldestEntry(Map.Entry&lt;K, V&gt; eldest) &#123; return size() &gt; this.capacity; &#125;&#125;]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HashMap]]></title>
    <url>%2FJava%E9%9B%86%E5%90%88%2FHashMap%2F</url>
    <content type="text"><![CDATA[HashMap采用key/value存储结构，每个key对应唯一的value，key和value都允许null值 非线程安全 不保证元素存储的顺序,其存储结构JDK8版本采用了数组+链表+红黑树的复杂结构，添加元素时根据hash值计算出元素在数组中的位置，若该位置没有元素则直接把元素放置在此处否则把元素以链表的形式放在链表的尾部当一个链表的个数达到一定的数量(且数组的长度达到一定的长度)后，则把链表转化为红黑树从而提高效率：数组的查询效率O(1) 链表查询效率O(n) 红黑树查询效率O(log n) 继承关系如下： ###JDK8 主要属性12345678910111213141516171819202122232425public class HashMap&lt;K,V&gt; extends AbstractMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Cloneable, Serializable &#123; private static final long serialVersionUID = 362498820763181265L; //初始默认容量 必须是2的次幂 static final int DEFAULT_INITIAL_CAPACITY = 1 &lt;&lt; 4; // aka 16 //默认装载因子 static final float DEFAULT_LOAD_FACTOR = 0.75f; //链表长度大于8 则转化为红黑树（且桶的容量大于64） static final int TREEIFY_THRESHOLD = 8; //链表长度小于6 则退化为链表 static final int UNTREEIFY_THRESHOLD = 6; //当桶中数据达到64才进行树化 static final int MIN_TREEIFY_CAPACITY = 64; //数组 又称桶 transient Node&lt;K,V&gt;[] table; //作为entrySet()的缓存 transient Set&lt;Map.Entry&lt;K,V&gt;&gt; entrySet; //元素的数量 transient int size; //修改次数 迭代时执行快速失败策略 transient int modCount; //当桶中元素到多少时进行扩容 threshold = capacity * loadFactor int threshold; //装载因子 final float loadFactor; 内部类123456789101112131415161718192021222324252627//链表节点static class Node&lt;K,V&gt; implements Map.Entry&lt;K,V&gt; &#123; final int hash; final K key; V value; Node&lt;K,V&gt; next; Node(int hash, K key, V value, Node&lt;K,V&gt; next) &#123; this.hash = hash; this.key = key; this.value = value; this.next = next; &#125; ... ...&#125;//红黑树节点static final class TreeNode&lt;K,V&gt; extends LinkedHashMap.Entry&lt;K,V&gt; &#123; TreeNode&lt;K,V&gt; parent; // red-black tree links TreeNode&lt;K,V&gt; left; TreeNode&lt;K,V&gt; right; TreeNode&lt;K,V&gt; prev; // needed to unlink next upon deletion boolean red; TreeNode(int hash, K key, V val, Node&lt;K,V&gt; next) &#123; super(hash, key, val, next); &#125; ... ... &#125; 构造器1234567891011121314151617181920212223242526272829303132333435public HashMap(int initialCapacity, float loadFactor) &#123; if (initialCapacity &lt; 0) throw new IllegalArgumentException("Illegal initial capacity: " + initialCapacity); if (initialCapacity &gt; MAXIMUM_CAPACITY) initialCapacity = MAXIMUM_CAPACITY; if (loadFactor &lt;= 0 || Float.isNaN(loadFactor)) throw new IllegalArgumentException("Illegal load factor: " + loadFactor); this.loadFactor = loadFactor; this.threshold = tableSizeFor(initialCapacity);&#125;public HashMap(int initialCapacity) &#123; this(initialCapacity, DEFAULT_LOAD_FACTOR);&#125;public HashMap() &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; // all other fields defaulted&#125;public HashMap(Map&lt;? extends K, ? extends V&gt; m) &#123; this.loadFactor = DEFAULT_LOAD_FACTOR; putMapEntries(m, false);&#125;//将给定容量转化为2的次幂大小static final int tableSizeFor(int cap) &#123; int n = cap - 1; n |= n &gt;&gt;&gt; 1; n |= n &gt;&gt;&gt; 2; n |= n &gt;&gt;&gt; 4; n |= n &gt;&gt;&gt; 8; n |= n &gt;&gt;&gt; 16; return (n &lt; 0) ? 1 : (n &gt;= MAXIMUM_CAPACITY) ? MAXIMUM_CAPACITY : n + 1;&#125; Hash函数1234static final int hash(Object key) &#123; int h; return (key == null) ? 0 : (h = key.hashCode()) ^ (h &gt;&gt;&gt; 16);&#125; 添加元素123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596public V put(K key, V value) &#123; return putVal(hash(key), key, value, false, true);&#125;final V putVal(int hash, K key, V value, boolean onlyIfAbsent, boolean evict) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, i; if ((tab = table) == null || (n = tab.length) == 0) n = (tab = resize()).length; //如果目标位置没有节点 if ((p = tab[i = (n - 1) &amp; hash]) == null) tab[i] = newNode(hash, key, value, null); else &#123; Node&lt;K,V&gt; e; K k; //如果第一个节点就是目标节点 if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) e = p; else if (p instanceof TreeNode)//如果已经树化则更新红黑树 e = ((TreeNode&lt;K,V&gt;)p).putTreeVal(this, tab, hash, key, value); else &#123;//遍历链表找到目标节点更新 如果没有 则追加到链表尾部 for (int binCount = 0; ; ++binCount) &#123; if ((e = p.next) == null) &#123; p.next = newNode(hash, key, value, null); //如果链表长度 超过TREEIFY_THRESHOLD则 进行树化 if (binCount &gt;= TREEIFY_THRESHOLD - 1) // -1 for 1st treeifyBin(tab, hash);//红黑树化 break; &#125; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) break;//找到目标节点 则跳出循环 p = e; &#125; &#125; //如果map中存在对于key的节点 则更新之 并返回原始值 if (e != null) &#123; // existing mapping for key V oldValue = e.value; if (!onlyIfAbsent || oldValue == null) e.value = value; afterNodeAccess(e); return oldValue; &#125; &#125; ++modCount; if (++size &gt; threshold)//超过阈值threshold则进行扩容 resize(); afterNodeInsertion(evict); return null;&#125;//红黑树操作final TreeNode&lt;K,V&gt; putTreeVal(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, int h, K k, V v) &#123; Class&lt;?&gt; kc = null; boolean searched = false; TreeNode&lt;K,V&gt; root = (parent != null) ? root() : this; for (TreeNode&lt;K,V&gt; p = root;;) &#123; int dir, ph; K pk; if ((ph = p.hash) &gt; h) dir = -1; else if (ph &lt; h) dir = 1; else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) &#123; if (!searched) &#123; TreeNode&lt;K,V&gt; q, ch; searched = true; if (((ch = p.left) != null &amp;&amp; (q = ch.find(h, k, kc)) != null) || ((ch = p.right) != null &amp;&amp; (q = ch.find(h, k, kc)) != null)) return q; &#125; dir = tieBreakOrder(k, pk); &#125; TreeNode&lt;K,V&gt; xp = p; if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123; Node&lt;K,V&gt; xpn = xp.next; TreeNode&lt;K,V&gt; x = map.newTreeNode(h, k, v, xpn); if (dir &lt;= 0) xp.left = x; else xp.right = x; xp.next = x; x.parent = x.prev = xp; if (xpn != null) ((TreeNode&lt;K,V&gt;)xpn).prev = x; moveRootToFront(tab, balanceInsertion(root, x)); return null; &#125; &#125;&#125; 树化12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123; int n, index; Node&lt;K,V&gt; e; if (tab == null || (n = tab.length) &lt; MIN_TREEIFY_CAPACITY) resize(); else if ((e = tab[index = (n - 1) &amp; hash]) != null) &#123; TreeNode&lt;K,V&gt; hd = null, tl = null; do &#123; TreeNode&lt;K,V&gt; p = replacementTreeNode(e, null); if (tl == null) hd = p; else &#123; p.prev = tl; tl.next = p; &#125; tl = p; &#125; while ((e = e.next) != null); if ((tab[index] = hd) != null) hd.treeify(tab); &#125;&#125;final void treeify(Node&lt;K,V&gt;[] tab) &#123; TreeNode&lt;K,V&gt; root = null; for (TreeNode&lt;K,V&gt; x = this, next; x != null; x = next) &#123; next = (TreeNode&lt;K,V&gt;)x.next; x.left = x.right = null; if (root == null) &#123; x.parent = null; x.red = false; root = x; &#125; else &#123; K k = x.key; int h = x.hash; Class&lt;?&gt; kc = null; for (TreeNode&lt;K,V&gt; p = root;;) &#123; int dir, ph; K pk = p.key; if ((ph = p.hash) &gt; h) dir = -1; else if (ph &lt; h) dir = 1; else if ((kc == null &amp;&amp; (kc = comparableClassFor(k)) == null) || (dir = compareComparables(kc, k, pk)) == 0) dir = tieBreakOrder(k, pk); TreeNode&lt;K,V&gt; xp = p; if ((p = (dir &lt;= 0) ? p.left : p.right) == null) &#123; x.parent = xp; if (dir &lt;= 0) xp.left = x; else xp.right = x; root = balanceInsertion(root, x); break; &#125; &#125; &#125; &#125; moveRootToFront(tab, root);&#125; 扩容12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273final Node&lt;K,V&gt;[] resize() &#123; Node&lt;K,V&gt;[] oldTab = table; int oldCap = (oldTab == null) ? 0 : oldTab.length; int oldThr = threshold; int newCap, newThr = 0; if (oldCap &gt; 0) &#123; if (oldCap &gt;= MAXIMUM_CAPACITY) &#123; threshold = Integer.MAX_VALUE; return oldTab; &#125; else if ((newCap = oldCap &lt;&lt; 1) &lt; MAXIMUM_CAPACITY &amp;&amp; oldCap &gt;= DEFAULT_INITIAL_CAPACITY) newThr = oldThr &lt;&lt; 1; // double threshold &#125; else if (oldThr &gt; 0) // initial capacity was placed in threshold newCap = oldThr; else &#123; // zero initial threshold signifies using defaults newCap = DEFAULT_INITIAL_CAPACITY; newThr = (int)(DEFAULT_LOAD_FACTOR * DEFAULT_INITIAL_CAPACITY); &#125; if (newThr == 0) &#123; float ft = (float)newCap * loadFactor; newThr = (newCap &lt; MAXIMUM_CAPACITY &amp;&amp; ft &lt; (float)MAXIMUM_CAPACITY ? (int)ft : Integer.MAX_VALUE); &#125; threshold = newThr; @SuppressWarnings(&#123;"rawtypes","unchecked"&#125;) Node&lt;K,V&gt;[] newTab = (Node&lt;K,V&gt;[])new Node[newCap]; table = newTab; if (oldTab != null) &#123; for (int j = 0; j &lt; oldCap; ++j) &#123; Node&lt;K,V&gt; e; if ((e = oldTab[j]) != null) &#123; oldTab[j] = null; if (e.next == null) newTab[e.hash &amp; (newCap - 1)] = e; else if (e instanceof TreeNode) ((TreeNode&lt;K,V&gt;)e).split(this, newTab, j, oldCap); else &#123; // preserve order Node&lt;K,V&gt; loHead = null, loTail = null; Node&lt;K,V&gt; hiHead = null, hiTail = null; Node&lt;K,V&gt; next; do &#123; next = e.next; if ((e.hash &amp; oldCap) == 0) &#123; if (loTail == null) loHead = e; else loTail.next = e; loTail = e; &#125; else &#123; if (hiTail == null) hiHead = e; else hiTail.next = e; hiTail = e; &#125; &#125; while ((e = next) != null); if (loTail != null) &#123; loTail.next = null; newTab[j] = loHead; &#125; if (hiTail != null) &#123; hiTail.next = null; newTab[j + oldCap] = hiHead; &#125; &#125; &#125; &#125; &#125; return newTab;&#125; 获取元素123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public V get(Object key) &#123; Node&lt;K,V&gt; e; return (e = getNode(hash(key), key)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; getNode(int hash, Object key) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; first, e; int n; K k; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (first = tab[(n - 1) &amp; hash]) != null) &#123; if (first.hash == hash &amp;&amp; // always check first node ((k = first.key) == key || (key != null &amp;&amp; key.equals(k)))) return first; if ((e = first.next) != null) &#123; if (first instanceof TreeNode) return ((TreeNode&lt;K,V&gt;)first).getTreeNode(hash, key); do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) return e; &#125; while ((e = e.next) != null); &#125; &#125; return null;&#125;//红黑树操作final TreeNode&lt;K,V&gt; getTreeNode(int h, Object k) &#123; return ((parent != null) ? root() : this).find(h, k, null);&#125;final TreeNode&lt;K,V&gt; root() &#123; for (TreeNode&lt;K,V&gt; r = this, p;;) &#123; if ((p = r.parent) == null) return r; r = p; &#125;&#125;final TreeNode&lt;K,V&gt; find(int h, Object k, Class&lt;?&gt; kc) &#123; TreeNode&lt;K,V&gt; p = this; do &#123; int ph, dir; K pk; TreeNode&lt;K,V&gt; pl = p.left, pr = p.right, q; if ((ph = p.hash) &gt; h) p = pl; else if (ph &lt; h) p = pr; else if ((pk = p.key) == k || (k != null &amp;&amp; k.equals(pk))) return p; else if (pl == null) p = pr; else if (pr == null) p = pl; else if ((kc != null || (kc = comparableClassFor(k)) != null) &amp;&amp; (dir = compareComparables(kc, k, pk)) != 0) p = (dir &lt; 0) ? pl : pr; else if ((q = pr.find(h, k, kc)) != null) return q; else p = pl; &#125; while (p != null); return null;&#125; 删除元素123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141public V remove(Object key) &#123; Node&lt;K,V&gt; e; return (e = removeNode(hash(key), key, null, false, true)) == null ? null : e.value;&#125;final Node&lt;K,V&gt; removeNode(int hash, Object key, Object value, boolean matchValue, boolean movable) &#123; Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; p; int n, index; if ((tab = table) != null &amp;&amp; (n = tab.length) &gt; 0 &amp;&amp; (p = tab[index = (n - 1) &amp; hash]) != null) &#123; Node&lt;K,V&gt; node = null, e; K k; V v; if (p.hash == hash &amp;&amp; ((k = p.key) == key || (key != null &amp;&amp; key.equals(k)))) node = p; else if ((e = p.next) != null) &#123; if (p instanceof TreeNode) node = ((TreeNode&lt;K,V&gt;)p).getTreeNode(hash, key); else &#123; do &#123; if (e.hash == hash &amp;&amp; ((k = e.key) == key || (key != null &amp;&amp; key.equals(k)))) &#123; node = e; break; &#125; p = e; &#125; while ((e = e.next) != null); &#125; &#125; if (node != null &amp;&amp; (!matchValue || (v = node.value) == value || (value != null &amp;&amp; value.equals(v)))) &#123; if (node instanceof TreeNode) ((TreeNode&lt;K,V&gt;)node).removeTreeNode(this, tab, movable); else if (node == p) tab[index] = node.next; else p.next = node.next; ++modCount; --size; afterNodeRemoval(node); return node; &#125; &#125; return null;&#125;//红黑树操作final void removeTreeNode(HashMap&lt;K,V&gt; map, Node&lt;K,V&gt;[] tab, boolean movable) &#123; int n; if (tab == null || (n = tab.length) == 0) return; int index = (n - 1) &amp; hash; TreeNode&lt;K,V&gt; first = (TreeNode&lt;K,V&gt;)tab[index], root = first, rl; TreeNode&lt;K,V&gt; succ = (TreeNode&lt;K,V&gt;)next, pred = prev; if (pred == null) tab[index] = first = succ; else pred.next = succ; if (succ != null) succ.prev = pred; if (first == null) return; if (root.parent != null) root = root.root(); if (root == null || root.right == null || (rl = root.left) == null || rl.left == null) &#123; tab[index] = first.untreeify(map); // too small return; &#125; TreeNode&lt;K,V&gt; p = this, pl = left, pr = right, replacement; if (pl != null &amp;&amp; pr != null) &#123; TreeNode&lt;K,V&gt; s = pr, sl; while ((sl = s.left) != null) // find successor s = sl; boolean c = s.red; s.red = p.red; p.red = c; // swap colors TreeNode&lt;K,V&gt; sr = s.right; TreeNode&lt;K,V&gt; pp = p.parent; if (s == pr) &#123; // p was s's direct parent p.parent = s; s.right = p; &#125; else &#123; TreeNode&lt;K,V&gt; sp = s.parent; if ((p.parent = sp) != null) &#123; if (s == sp.left) sp.left = p; else sp.right = p; &#125; if ((s.right = pr) != null) pr.parent = s; &#125; p.left = null; if ((p.right = sr) != null) sr.parent = p; if ((s.left = pl) != null) pl.parent = s; if ((s.parent = pp) == null) root = s; else if (p == pp.left) pp.left = s; else pp.right = s; if (sr != null) replacement = sr; else replacement = p; &#125; else if (pl != null) replacement = pl; else if (pr != null) replacement = pr; else replacement = p; if (replacement != p) &#123; TreeNode&lt;K,V&gt; pp = replacement.parent = p.parent; if (pp == null) root = replacement; else if (p == pp.left) pp.left = replacement; else pp.right = replacement; p.left = p.right = p.parent = null; &#125; TreeNode&lt;K,V&gt; r = p.red ? root : balanceDeletion(root, replacement); if (replacement == p) &#123; // detach TreeNode&lt;K,V&gt; pp = p.parent; p.parent = null; if (pp != null) &#123; if (p == pp.left) pp.left = null; else if (p == pp.right) pp.right = null; &#125; &#125; if (movable) moveRootToFront(tab, r);&#125; 总结]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>Map</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CopyOnWriteArrayList]]></title>
    <url>%2FJava%E9%9B%86%E5%90%88%2FCopyOnWriteArrayList%2F</url>
    <content type="text"><![CDATA[CopyOnWriteArrayList是ArrayList的线程安全版本，通过使用重入锁在添加、修改数据时加锁复制一份原始数组更新完数据后再替换原始数组，可见其比较适合读多写少的场景。 继承关系如下： 主要属性12345678910public class CopyOnWriteArrayList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable &#123; private static final long serialVersionUID = 8673264195747942595L; //修改时使用的重入锁 /** The lock protecting all mutators */ final transient ReentrantLock lock = new ReentrantLock(); //存储数据 /** The array, accessed only via getArray/setArray. */ private transient volatile Object[] array; 构造器123456789101112131415161718public CopyOnWriteArrayList() &#123; setArray(new Object[0]);&#125;public CopyOnWriteArrayList(Collection&lt;? extends E&gt; c) &#123; Object[] elements; if (c.getClass() == CopyOnWriteArrayList.class) elements = ((CopyOnWriteArrayList&lt;?&gt;)c).getArray(); else &#123; elements = c.toArray(); // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elements.getClass() != Object[].class) elements = Arrays.copyOf(elements, elements.length, Object[].class); &#125; setArray(elements);&#125;public CopyOnWriteArrayList(E[] toCopyIn) &#123; setArray(Arrays.copyOf(toCopyIn, toCopyIn.length, Object[].class));&#125; 添加元素123456789101112131415public boolean add(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; //复制一份数组 插入数据 并复制回原始数组 Object[] newElements = Arrays.copyOf(elements, len + 1); newElements[len] = e; setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125;&#125; 更新元素12345678910111213141516171819202122232425262728293031323334353637383940414243444546public E set(int index, E element) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); E oldValue = get(elements, index); if (oldValue != element) &#123; int len = elements.length; Object[] newElements = Arrays.copyOf(elements, len); newElements[index] = element; setArray(newElements); &#125; else &#123; // Not quite a no-op; ensures volatile write semantics setArray(elements); &#125; return oldValue; &#125; finally &#123; lock.unlock(); &#125;&#125;public void add(int index, E element) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; if (index &gt; len || index &lt; 0) throw new IndexOutOfBoundsException("Index: "+index+ ", Size: "+len); Object[] newElements; int numMoved = len - index; if (numMoved == 0) newElements = Arrays.copyOf(elements, len + 1); else &#123; newElements = new Object[len + 1]; System.arraycopy(elements, 0, newElements, 0, index); System.arraycopy(elements, index, newElements, index + 1, numMoved); &#125; newElements[index] = element; setArray(newElements); &#125; finally &#123; lock.unlock(); &#125;&#125; 删除元素123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public E remove(int index) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] elements = getArray(); int len = elements.length; E oldValue = get(elements, index); int numMoved = len - index - 1; if (numMoved == 0) setArray(Arrays.copyOf(elements, len - 1)); else &#123; Object[] newElements = new Object[len - 1]; System.arraycopy(elements, 0, newElements, 0, index); System.arraycopy(elements, index + 1, newElements, index, numMoved); setArray(newElements); &#125; return oldValue; &#125; finally &#123; lock.unlock(); &#125;&#125;public boolean remove(Object o) &#123; Object[] snapshot = getArray(); int index = indexOf(o, snapshot, 0, snapshot.length); return (index &lt; 0) ? false : remove(o, snapshot, index);&#125;private static int indexOf(Object o, Object[] elements, int index, int fence) &#123; if (o == null) &#123; for (int i = index; i &lt; fence; i++) if (elements[i] == null) return i; &#125; else &#123; for (int i = index; i &lt; fence; i++) if (o.equals(elements[i])) return i; &#125; return -1;&#125;private boolean remove(Object o, Object[] snapshot, int index) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; Object[] current = getArray(); int len = current.length; if (snapshot != current) findIndex: &#123; int prefix = Math.min(index, len); for (int i = 0; i &lt; prefix; i++) &#123; if (current[i] != snapshot[i] &amp;&amp; eq(o, current[i])) &#123; index = i; break findIndex; &#125; &#125; if (index &gt;= len) return false; if (current[index] == o) break findIndex; index = indexOf(o, current, index, len); if (index &lt; 0) return false; &#125; Object[] newElements = new Object[len - 1]; System.arraycopy(current, 0, newElements, 0, index); System.arraycopy(current, index + 1, newElements, index, len - index - 1); setArray(newElements); return true; &#125; finally &#123; lock.unlock(); &#125;&#125; 总结 使用ReentrantLock重入锁保证线程安全 写操作先拷贝一份数据 更新完毕后 替换原始数组 空间复杂度O(n) 性能低下 读操作支持随机访问 时间复杂度O(1) 采用读写分离思想，读不加锁 写加锁且占用较大内存空间 故适合读多写少的场景 只保证最终一致 不能保证实时一致]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedList]]></title>
    <url>%2FJava%E9%9B%86%E5%90%88%2FLinkedList%2F</url>
    <content type="text"><![CDATA[LinkedList是一个双向链表实现的list，允许null值 线程非安全 还可以作为队列或栈来使用 其继承关系如下： 可看出LinkedList不仅实现了list接口 还是先了Queue或Deque接口 主要属性12345678910111213141516171819202122232425public class LinkedList&lt;E&gt; extends AbstractSequentialList&lt;E&gt; implements List&lt;E&gt;, Deque&lt;E&gt;, Cloneable, java.io.Serializable&#123; //元素个数 transient int size = 0; //指向链表第一个节点 transient Node&lt;E&gt; first; //指向链表最后一个节点 transient Node&lt;E&gt; last; private static class Node&lt;E&gt; &#123; E item; Node&lt;E&gt; next; Node&lt;E&gt; prev; Node(Node&lt;E&gt; prev, E element, Node&lt;E&gt; next) &#123; this.item = element; this.next = next; this.prev = prev; &#125; &#125; ... ...&#125; 构造器123456public LinkedList() &#123;&#125;public LinkedList(Collection&lt;? extends E&gt; c) &#123; this(); addAll(c);&#125; 添加元素作为队列1234567891011121314151617181920212223242526272829303132public void addFirst(E e) &#123; linkFirst(e);&#125;private void linkFirst(E e) &#123; final Node&lt;E&gt; f = first; final Node&lt;E&gt; newNode = new Node&lt;&gt;(null, e, f); first = newNode; if (f == null) last = newNode; else f.prev = newNode; size++; modCount++;&#125;public boolean add(E e) &#123; linkLast(e); return true;&#125;void linkLast(E e) &#123; final Node&lt;E&gt; l = last; final Node&lt;E&gt; newNode = new Node&lt;&gt;(l, e, null); last = newNode; if (l == null)//当前没有元素 first = newNode; else l.next = newNode;//将当前节点追加到last后 size++; modCount++;&#125; 作为list12345678910111213141516171819202122232425262728293031323334353637public void add(int index, E element) &#123; checkPositionIndex(index); if (index == size) linkLast(element); else linkBefore(element, node(index));&#125;//查找指定索引位置的节点Node&lt;E&gt; node(int index) &#123; // assert isElementIndex(index); if (index &lt; (size &gt;&gt; 1)) &#123; Node&lt;E&gt; x = first; for (int i = 0; i &lt; index; i++) x = x.next; return x; &#125; else &#123; Node&lt;E&gt; x = last; for (int i = size - 1; i &gt; index; i--) x = x.prev; return x; &#125;&#125;void linkBefore(E e, Node&lt;E&gt; succ) &#123; // assert succ != null; final Node&lt;E&gt; pred = succ.prev; final Node&lt;E&gt; newNode = new Node&lt;&gt;(pred, e, succ); succ.prev = newNode; if (pred == null) first = newNode; else pred.next = newNode; size++; modCount++;&#125; 删除元素12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879public E remove() &#123; return removeFirst();&#125;public E removeFirst() &#123; final Node&lt;E&gt; f = first; if (f == null) throw new NoSuchElementException(); return unlinkFirst(f);&#125;private E unlinkFirst(Node&lt;E&gt; f) &#123; // assert f == first &amp;&amp; f != null; final E element = f.item; final Node&lt;E&gt; next = f.next; f.item = null; f.next = null; // help GC first = next; if (next == null) last = null; else next.prev = null; size--; modCount++; return element;&#125;public E removeLast() &#123; final Node&lt;E&gt; l = last; if (l == null) throw new NoSuchElementException(); return unlinkLast(l);&#125;private E unlinkLast(Node&lt;E&gt; l) &#123; // assert l == last &amp;&amp; l != null; final E element = l.item; final Node&lt;E&gt; prev = l.prev; l.item = null; l.prev = null; // help GC last = prev; if (prev == null) first = null; else prev.next = null; size--; modCount++; return element;&#125;public E remove(int index) &#123; checkElementIndex(index); return unlink(node(index));&#125;E unlink(Node&lt;E&gt; x) &#123; // assert x != null; final E element = x.item; final Node&lt;E&gt; next = x.next; final Node&lt;E&gt; prev = x.prev; if (prev == null) &#123; first = next; &#125; else &#123; prev.next = next; x.prev = null; &#125; if (next == null) &#123; last = prev; &#125; else &#123; next.prev = prev; x.next = null; &#125; x.item = null; size--; modCount++; return element;&#125; 栈123456public void push(E e) &#123; addFirst(e);&#125;public E pop() &#123; return removeFirst();&#125; 总结 双向链表实现的list 实现了Queue、Deque接口 具有队列和双端队列、栈的特性 队列首尾添加、删除元素非常高效 时间复杂度为O(1) 在中间添加、删除元素 需要遍历list 比较低效 时间复杂度为O(n) 不支持随机访问 故访问非首尾节点比较低效 功能上等于ArrayList+ArrayDeque]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayList]]></title>
    <url>%2FJava%E9%9B%86%E5%90%88%2FArrayList%2F</url>
    <content type="text"><![CDATA[ArrayList是数组实现的的list，相比数组它的容量可以动态变化 非线程安全其继承结构如下：ArrayList实现接口： List 提供基础的添加、删除、遍历等操作 RandomAccess 提供随机访问的能力 Cloneable 可以被克隆 Serializable 可以被序列化 主要属性123456789101112131415public class ArrayList&lt;E&gt; extends AbstractList&lt;E&gt; implements List&lt;E&gt;, RandomAccess, Cloneable, java.io.Serializable&#123; private static final long serialVersionUID = 8683452581122892189L; //默认容量 private static final int DEFAULT_CAPACITY = 10; //空数组 若传入容量为0时使用 private static final Object[] EMPTY_ELEMENTDATA = &#123;&#125;; //空数组 传入容量时使用 添加第一个元素时会重新初始化为默认容量大小 private static final Object[] DEFAULTCAPACITY_EMPTY_ELEMENTDATA = &#123;&#125;; //存储元素的数组 transient Object[] elementData; //集合中元素的个数 private int size; private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; 构造器123456789101112131415161718192021222324public ArrayList(int initialCapacity) &#123; if (initialCapacity &gt; 0) &#123;//传入容量大于0 则新建一个数组 this.elementData = new Object[initialCapacity]; &#125; else if (initialCapacity == 0) &#123;//等于0 使用空数组EMPTY_ELEMENTDATA this.elementData = EMPTY_ELEMENTDATA; &#125; else &#123;//传入小于0 抛出异常 throw new IllegalArgumentException("Illegal Capacity: "+ initialCapacity); &#125;&#125;public ArrayList() &#123;//默认不设置容量 则使用默认容量10 this.elementData = DEFAULTCAPACITY_EMPTY_ELEMENTDATA;&#125;public ArrayList(Collection&lt;? extends E&gt; c) &#123; elementData = c.toArray(); if ((size = elementData.length) != 0) &#123; // c.toArray might (incorrectly) not return Object[] (see 6260652) if (elementData.getClass() != Object[].class) elementData = Arrays.copyOf(elementData, size, Object[].class); &#125; else &#123; // replace with empty array. this.elementData = EMPTY_ELEMENTDATA; &#125;&#125; 加入元素123456789101112131415161718192021public boolean add(E e) &#123; ensureCapacityInternal(size + 1); // Increments modCount!! elementData[size++] = e; return true;&#125;private void ensureCapacityInternal(int minCapacity) &#123; if (elementData == DEFAULTCAPACITY_EMPTY_ELEMENTDATA) &#123; minCapacity = Math.max(DEFAULT_CAPACITY, minCapacity); &#125; ensureExplicitCapacity(minCapacity);&#125;private void ensureExplicitCapacity(int minCapacity) &#123; modCount++; // overflow-conscious code if (minCapacity - elementData.length &gt; 0) grow(minCapacity);&#125; 扩容123456789101112131415161718private void grow(int minCapacity) &#123; // overflow-conscious code int oldCapacity = elementData.length; int newCapacity = oldCapacity + (oldCapacity &gt;&gt; 1); if (newCapacity - minCapacity &lt; 0) newCapacity = minCapacity; if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); // minCapacity is usually close to size, so this is a win: elementData = Arrays.copyOf(elementData, newCapacity);&#125;private static int hugeCapacity(int minCapacity) &#123; if (minCapacity &lt; 0) // overflow throw new OutOfMemoryError(); return (minCapacity &gt; MAX_ARRAY_SIZE) ? Integer.MAX_VALUE : MAX_ARRAY_SIZE;&#125;]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>List</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayDeque]]></title>
    <url>%2FJava%E9%9B%86%E5%90%88%2FArrayDeque%2F</url>
    <content type="text"><![CDATA[ArrayDeque实现了Deque接口，内部存储数据结构为可调整大小的数组，而且没有容量限制，线程非安全。其继承关系如下： Deque12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061void addFirst(E e);void addLast(E e);boolean offerFirst(E e);boolean offerLast(E e);E removeFirst();E removeLast();E pollFirst();E pollLast();E getFirst();E getLast();E peekFirst();E peekLast();boolean removeFirstOccurrence(Object o);boolean removeLastOccurrence(Object o);// *** Queue methods ***boolean add(E e);boolean offer(E e);E remove();E poll();E element();E peek();// *** Stack methods ***void push(E e);E pop();// *** Collection methods ***boolean remove(Object o);boolean contains(Object o);public int size();Iterator&lt;E&gt; iterator();Iterator&lt;E&gt; descendingIterator(); 主要属性12345678public class ArrayDeque&lt;E&gt; extends AbstractCollection&lt;E&gt; implements Deque&lt;E&gt;, Cloneable, Serializable&#123;transient Object[] elements;transient int head;transient int tail;private static final int MIN_INITIAL_CAPACITY = 8; 构造器12345678910public ArrayDeque() &#123; elements = new Object[16];&#125;public ArrayDeque(int numElements) &#123; allocateElements(numElements);&#125;public ArrayDeque(Collection&lt;? extends E&gt; c) &#123; allocateElements(c.size()); addAll(c);&#125; 入队1234567891011public boolean add(E e) &#123; addLast(e); return true;&#125;public void addLast(E e) &#123; if (e == null) throw new NullPointerException(); elements[tail] = e; if ( (tail = (tail + 1) &amp; (elements.length - 1)) == head) doubleCapacity();&#125; 扩容123456789101112131415private void doubleCapacity() &#123; assert head == tail; int p = head; int n = elements.length; int r = n - p; // number of elements to the right of p int newCapacity = n &lt;&lt; 1; if (newCapacity &lt; 0) throw new IllegalStateException("Sorry, deque too big"); Object[] a = new Object[newCapacity]; System.arraycopy(elements, p, a, 0, r); System.arraycopy(elements, 0, a, r, p); elements = a; head = 0; tail = n;&#125; 出队12345678910111213141516171819202122232425public E remove() &#123; return removeFirst();&#125;public E removeFirst() &#123; E x = pollFirst(); if (x == null) throw new NoSuchElementException(); return x;&#125;public E poll() &#123; return pollFirst();&#125;public E pollFirst() &#123; int h = head; @SuppressWarnings("unchecked") E result = (E) elements[h]; // Element is null if deque empty if (result == null) return null; elements[h] = null; // Must null out slot head = (h + 1) &amp; (elements.length - 1); return result;&#125; 总结 ArrayDeque采用数组实现双端队列 出队入队是通过头尾指针循环利用数组实现 容量不足时是会扩容的，每次扩容容量增加一倍 可以直接作为栈使用]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ConcurrentLinkedQueue]]></title>
    <url>%2FJava%E9%9B%86%E5%90%88%2FConcurrentLinkedQueue%2F</url>
    <content type="text"><![CDATA[ConcurrentLinkedQueue是基于链表的无界队列，队列中数据遵循FIFO，不允许使用null值。从ConcurrentLinkedQueue的类继承关系如下图：可看出其实现了Queue接口但没有实现BlockingQueue故ConcurrentLinkedQueue不是阻塞队列，不能用于线程池中。 主要属性123456789101112131415161718192021public class ConcurrentLinkedQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements Queue&lt;E&gt;, java.io.Serializable &#123; private static final long serialVersionUID = 196745693267521676L; //典型的单链表结构 private static class Node&lt;E&gt; &#123; volatile E item; volatile Node&lt;E&gt; next; /** * Constructs a new node. Uses relaxed write because item can * only be seen after publication via casNext. */ Node(E item) &#123; UNSAFE.putObject(this, itemOffset, item); &#125; ... ... &#125; //队列中第一个存活的节点 private transient volatile Node&lt;E&gt; head; //队列中最后一个节点 private transient volatile Node&lt;E&gt; tail; 构造器123456789101112131415161718192021public ConcurrentLinkedQueue() &#123; head = tail = new Node&lt;E&gt;(null);&#125;public ConcurrentLinkedQueue(Collection&lt;? extends E&gt; c) &#123; Node&lt;E&gt; h = null, t = null; for (E e : c) &#123; checkNotNull(e); Node&lt;E&gt; newNode = new Node&lt;E&gt;(e); if (h == null) h = t = newNode; else &#123; t.lazySetNext(newNode); t = newNode; &#125; &#125; if (h == null) h = t = new Node&lt;E&gt;(null); head = h; tail = t;&#125; 入队1234567891011121314151617181920212223242526272829303132public boolean add(E e) &#123; return offer(e);&#125;public boolean offer(E e) &#123; checkNotNull(e); final Node&lt;E&gt; newNode = new Node&lt;E&gt;(e); for (Node&lt;E&gt; t = tail, p = t;;) &#123; Node&lt;E&gt; q = p.next; if (q == null) &#123;//说明已经是链表的尾部 直接入队 更新其next指向 // p is last node if (p.casNext(null, newNode)) &#123; // Successful CAS is the linearization point // for e to become an element of this queue, // and for newNode to become "live". if (p != t) // hop two nodes at a time casTail(t, newNode); // Failure is OK. return true; &#125; // Lost CAS race to another thread; re-read next &#125; else if (p == q) // We have fallen off list. If tail is unchanged, it // will also be off-list, in which case we need to // jump to head, from which all live nodes are always // reachable. Else the new tail is a better bet. p = (t != (t = tail)) ? t : head; else//t并非tail 则更新p的值 // Check for tail updates after two hops. p = (p != t &amp;&amp; t != (t = tail)) ? t : q; &#125;&#125; 出队1234567891011121314151617181920212223242526272829303132333435public E remove() &#123; E x = poll(); if (x != null) return x; else throw new NoSuchElementException();&#125;public E poll() &#123; restartFromHead: for (;;) &#123; for (Node&lt;E&gt; h = head, p = h, q;;) &#123; E item = p.item; //如果节点值不为空 则通过CAS更新为null if (item != null &amp;&amp; p.casItem(item, null)) &#123; // Successful CAS is the linearization point // for item to be removed from this queue. if (p != h) // hop two nodes at a time updateHead(h, ((q = p.next) != null) ? q : p); return item; &#125; else if ((q = p.next) == null) &#123;// updateHead(h, p); return null; &#125; else if (p == q) continue restartFromHead; else p = q; &#125; &#125;&#125;final void updateHead(Node&lt;E&gt; h, Node&lt;E&gt; p) &#123; if (h != p &amp;&amp; casHead(h, p)) h.lazySetNext(h);&#125; 总结ConcurrentLinkedQueue使用CAS + spin更新头尾节点来完成出队、入队操作。 特性 ConcurrentLinkedQueue LinkedBlockingQueue 线程安全 是 是 取元素 队列为空获取元素直接返回null poll()方法可以实现此功能 锁 无锁 通过CAS+Spin实现 使用重入锁 效率 高 较低 阻塞 非阻塞 阻塞 是否可在线程池使用 否 是]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LinkedTransferQueue]]></title>
    <url>%2FJava%E9%9B%86%E5%90%88%2FLinkedTransferQueue%2F</url>
    <content type="text"><![CDATA[LinkedTransferQueue是一个无界队列，是LinkedBlockingQueue、SynchronousQueue（公平模式）、ConcurrentLinkedQueue三者的集合体，综合了三者的方法提供更加高效的实现方式。其继承结构为： TransferQueueLinkedTransferQueue实现了TransferQueue接口，而TransferQueue接口继承自BlockingQueue，故LinkedTransferQueue也是一个阻塞队列。LinkedTransferQueue定义如下方法： 123456789//尝试移交元素boolean tryTransfer(E e);//移交元素void transfer(E e) throws InterruptedException;boolean tryTransfer(E e, long timeout, TimeUnit unit) throws InterruptedException;//判断是否有消费者boolean hasWaitingConsumer();//查看消费者的数量int getWaitingConsumerCount(); 主要属性1234567891011121314151617181920212223242526272829303132333435public class LinkedTransferQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements TransferQueue&lt;E&gt;, java.io.Serializable &#123; private static final long serialVersionUID = -3223113410248163686L; /** True if on multiprocessor */private static final boolean MP = Runtime.getRuntime().availableProcessors() &gt; 1;private static final int FRONT_SPINS = 1 &lt;&lt; 7;private static final int CHAINED_SPINS = FRONT_SPINS &gt;&gt;&gt; 1;static final int SWEEP_THRESHOLD = 32;static final class Node &#123; final boolean isData; // false if this is a request node volatile Object item; // initially non-null if isData; CASed to match volatile Node next; volatile Thread waiter; // null until waiting ... ...&#125;/** head of the queue; null until first enqueue */transient volatile Node head;/** tail of the queue; null until first append */private transient volatile Node tail;/** The number of apparent failures to unsplice removed nodes */private transient volatile int sweepVotes;/* * 放取元素的几种方式 */ //立即返回 用于非超时的poll()和tryTransfer()方法中private static final int NOW = 0; // for untimed poll, tryTransfer//异步 不会阻塞 用于放元素时 因内部使用无界单链表存储数据 不会阻塞放元素的过程private static final int ASYNC = 1; // for offer, put, add//同步 调用的时候若没有匹配 会阻塞直到匹配为止private static final int SYNC = 2; // for transfer, take//超时 用于有超时的poll()和tryTransfer()方法中private static final int TIMED = 3; // for timed poll, tryTransfer 入队123456789101112131415public void put(E e) &#123; xfer(e, true, ASYNC, 0);&#125;public boolean offer(E e) &#123; xfer(e, true, ASYNC, 0); return true;&#125;public boolean offer(E e, long timeout, TimeUnit unit) &#123; xfer(e, true, ASYNC, 0); return true;&#125;public boolean add(E e) &#123; xfer(e, true, ASYNC, 0); return true;&#125; 出队12345678910111213141516171819202122232425public E remove() &#123; E x = poll(); if (x != null) return x; else throw new NoSuchElementException();&#125;public E take() throws InterruptedException &#123; E e = xfer(null, false, SYNC, 0); if (e != null) return e; Thread.interrupted(); throw new InterruptedException();&#125;public E poll(long timeout, TimeUnit unit) throws InterruptedException &#123; E e = xfer(null, false, TIMED, unit.toNanos(timeout)); if (e != null || !Thread.interrupted()) return e; throw new InterruptedException();&#125;public E poll() &#123; return xfer(null, false, NOW, 0);&#125; 移交元素的方法1234567891011121314151617public boolean tryTransfer(E e) &#123; return xfer(e, true, NOW, 0) == null;&#125;public void transfer(E e) throws InterruptedException &#123; if (xfer(e, true, SYNC, 0) != null) &#123; Thread.interrupted(); // failure possible only due to interrupt throw new InterruptedException(); &#125;&#125;public boolean tryTransfer(E e, long timeout, TimeUnit unit) throws InterruptedException &#123; if (xfer(e, true, TIMED, unit.toNanos(timeout)) == null) return true; if (!Thread.interrupted()) return false; throw new InterruptedException();&#125; xfer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113private E xfer(E e, boolean haveData, int how, long nanos) &#123; if (haveData &amp;&amp; (e == null)) throw new NullPointerException(); Node s = null; // the node to append, if needed retry: for (;;) &#123; // restart on append race for (Node h = head, p = h; p != null;) &#123; // find &amp; match first node boolean isData = p.isData; Object item = p.item; if (item != p &amp;&amp; (item != null) == isData) &#123; // unmatched if (isData == haveData) // can't match break; if (p.casItem(item, e)) &#123; // match for (Node q = p; q != h;) &#123; Node n = q.next; // update by 2 unless singleton if (head == h &amp;&amp; casHead(h, n == null ? q : n)) &#123; h.forgetNext(); break; &#125; // advance and retry if ((h = head) == null || (q = h.next) == null || !q.isMatched()) break; // unless slack &lt; 2 &#125; LockSupport.unpark(p.waiter); return LinkedTransferQueue.&lt;E&gt;cast(item); &#125; &#125; Node n = p.next; p = (p != n) ? n : (h = head); // Use head if p offlist &#125; if (how != NOW) &#123; // No matches available if (s == null) s = new Node(e, haveData); Node pred = tryAppend(s, haveData); if (pred == null) continue retry; // lost race vs opposite mode if (how != ASYNC) return awaitMatch(s, pred, e, (how == TIMED), nanos); &#125; return e; // not waiting &#125;&#125;private Node tryAppend(Node s, boolean haveData) &#123; for (Node t = tail, p = t;;) &#123; // move p to last node and append Node n, u; // temps for reads of next &amp; tail if (p == null &amp;&amp; (p = head) == null) &#123; if (casHead(null, s)) return s; // initialize &#125; else if (p.cannotPrecede(haveData)) return null; // lost race vs opposite mode else if ((n = p.next) != null) // not last; keep traversing p = p != t &amp;&amp; t != (u = tail) ? (t = u) : // stale tail (p != n) ? n : null; // restart if off list else if (!p.casNext(null, s)) p = p.next; // re-read on CAS failure else &#123; if (p != t) &#123; // update if slack now &gt;= 2 while ((tail != t || !casTail(t, s)) &amp;&amp; (t = tail) != null &amp;&amp; (s = t.next) != null &amp;&amp; // advance and retry (s = s.next) != null &amp;&amp; s != t); &#125; return p; &#125; &#125;&#125;private E awaitMatch(Node s, Node pred, E e, boolean timed, long nanos) &#123; final long deadline = timed ? System.nanoTime() + nanos : 0L; Thread w = Thread.currentThread(); int spins = -1; // initialized after first item and cancel checks ThreadLocalRandom randomYields = null; // bound if needed for (;;) &#123; Object item = s.item; if (item != e) &#123; // matched // assert item != s; s.forgetContents(); // avoid garbage return LinkedTransferQueue.&lt;E&gt;cast(item); &#125; if ((w.isInterrupted() || (timed &amp;&amp; nanos &lt;= 0)) &amp;&amp; s.casItem(e, s)) &#123; // cancel unsplice(pred, s); return e; &#125; if (spins &lt; 0) &#123; // establish spins at/near front if ((spins = spinsFor(pred, s.isData)) &gt; 0) randomYields = ThreadLocalRandom.current(); &#125; else if (spins &gt; 0) &#123; // spin --spins; if (randomYields.nextInt(CHAINED_SPINS) == 0) Thread.yield(); // occasionally yield &#125; else if (s.waiter == null) &#123; s.waiter = w; // request unpark then recheck &#125; else if (timed) &#123; nanos = deadline - System.nanoTime(); if (nanos &gt; 0L) LockSupport.parkNanos(this, nanos); &#125; else &#123; LockSupport.park(this); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[PriorityBlockingQueue]]></title>
    <url>%2FJava%E9%9B%86%E5%90%88%2FPriorityBlockingQueue%2F</url>
    <content type="text"><![CDATA[PriorityBlockingQueue是一个无界阻塞队列，使用与PriorityQueue相同的排序规则，提供了阻塞获取数据的操作。 主要属性123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101@SuppressWarnings("unchecked")public class PriorityBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, java.io.Serializable &#123; private static final long serialVersionUID = 5595510919245408276L; /** * Default array capacity. */ private static final int DEFAULT_INITIAL_CAPACITY = 11; /** * The maximum size of array to allocate. * Some VMs reserve some header words in an array. * Attempts to allocate larger arrays may result in * OutOfMemoryError: Requested array size exceeds VM limit */ private static final int MAX_ARRAY_SIZE = Integer.MAX_VALUE - 8; /** * Priority queue represented as a balanced binary heap: the two * children of queue[n] are queue[2*n+1] and queue[2*(n+1)]. The * priority queue is ordered by comparator, or by the elements' * natural ordering, if comparator is null: For each node n in the * heap and each descendant d of n, n &lt;= d. The element with the * lowest value is in queue[0], assuming the queue is nonempty. */ private transient Object[] queue; /** * The number of elements in the priority queue. */ private transient int size; /** * The comparator, or null if priority queue uses elements' * natural ordering. */ private transient Comparator&lt;? super E&gt; comparator; /** * Lock used for all public operations */ private final ReentrantLock lock; /** * Condition for blocking when empty */ private final Condition notEmpty; /** * 扩容的时候使用的控制变量，CAS更新这个值 谁更新成功了谁扩容 其他线程让出CPU */ private transient volatile int allocationSpinLock; /** * 非阻塞的优先级队列 仅在序列化/反序列化时不会空 */ private PriorityQueue&lt;E&gt; q; /** * Creates a &#123;@code PriorityBlockingQueue&#125; with the default * initial capacity (11) that orders its elements according to * their &#123;@linkplain Comparable natural ordering&#125;. */ public PriorityBlockingQueue() &#123; this(DEFAULT_INITIAL_CAPACITY, null); &#125; /** * Creates a &#123;@code PriorityBlockingQueue&#125; with the specified * initial capacity that orders its elements according to their * &#123;@linkplain Comparable natural ordering&#125;. * * @param initialCapacity the initial capacity for this priority queue * @throws IllegalArgumentException if &#123;@code initialCapacity&#125; is less * than 1 */ public PriorityBlockingQueue(int initialCapacity) &#123; this(initialCapacity, null); &#125; /** * Creates a &#123;@code PriorityBlockingQueue&#125; with the specified initial * capacity that orders its elements according to the specified * comparator. * * @param initialCapacity the initial capacity for this priority queue * @param comparator the comparator that will be used to order this * priority queue. If &#123;@code null&#125;, the &#123;@linkplain Comparable * natural ordering&#125; of the elements will be used. * @throws IllegalArgumentException if &#123;@code initialCapacity&#125; is less * than 1 */ public PriorityBlockingQueue(int initialCapacity, Comparator&lt;? super E&gt; comparator) &#123; if (initialCapacity &lt; 1) throw new IllegalArgumentException(); this.lock = new ReentrantLock(); this.notEmpty = lock.newCondition(); this.comparator = comparator; this.queue = new Object[initialCapacity]; &#125; 入队123456789101112131415161718192021222324252627282930313233343536373839404142434445464748public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); final ReentrantLock lock = this.lock; lock.lock(); int n, cap; Object[] array; while ((n = size) &gt;= (cap = (array = queue).length)) tryGrow(array, cap); try &#123; Comparator&lt;? super E&gt; cmp = comparator; if (cmp == null) siftUpComparable(n, e, array); else siftUpUsingComparator(n, e, array, cmp); size = n + 1; notEmpty.signal(); &#125; finally &#123; lock.unlock(); &#125; return true;&#125;private static &lt;T&gt; void siftUpComparable(int k, T x, Object[] array) &#123; Comparable&lt;? super T&gt; key = (Comparable&lt;? super T&gt;) x; while (k &gt; 0) &#123; int parent = (k - 1) &gt;&gt;&gt; 1; Object e = array[parent]; if (key.compareTo((T) e) &gt;= 0) break; array[k] = e; k = parent; &#125; array[k] = key;&#125;private static &lt;T&gt; void siftUpUsingComparator(int k, T x, Object[] array, Comparator&lt;? super T&gt; cmp) &#123; while (k &gt; 0) &#123; int parent = (k - 1) &gt;&gt;&gt; 1; Object e = array[parent]; if (cmp.compare(x, (T) e) &gt;= 0) break; array[k] = e; k = parent; &#125; array[k] = x;&#125; 扩容12345678910111213141516171819202122232425262728293031private void tryGrow(Object[] array, int oldCap) &#123; lock.unlock(); // must release and then re-acquire main lock Object[] newArray = null; if (allocationSpinLock == 0 &amp;&amp; UNSAFE.compareAndSwapInt(this, allocationSpinLockOffset, 0, 1)) &#123; try &#123; int newCap = oldCap + ((oldCap &lt; 64) ? (oldCap + 2) : // grow faster if small (oldCap &gt;&gt; 1)); if (newCap - MAX_ARRAY_SIZE &gt; 0) &#123; // possible overflow int minCap = oldCap + 1; if (minCap &lt; 0 || minCap &gt; MAX_ARRAY_SIZE) throw new OutOfMemoryError(); newCap = MAX_ARRAY_SIZE; &#125; if (newCap &gt; oldCap &amp;&amp; queue == array) newArray = new Object[newCap]; &#125; finally &#123; allocationSpinLock = 0; &#125; &#125; if (newArray == null) // back off if another thread is allocating Thread.yield(); lock.lock(); if (newArray != null &amp;&amp; queue == array) &#123; queue = newArray; System.arraycopy(array, 0, newArray, 0, oldCap); &#125;&#125; 出队12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970public E take() throws InterruptedException &#123; final ReentrantLock lock = this.lock; lock.lockInterruptibly(); E result; try &#123; while ( (result = dequeue()) == null) notEmpty.await(); &#125; finally &#123; lock.unlock(); &#125; return result;&#125;private E dequeue() &#123; int n = size - 1; if (n &lt; 0) return null; else &#123; Object[] array = queue; E result = (E) array[0]; E x = (E) array[n]; array[n] = null; Comparator&lt;? super E&gt; cmp = comparator; if (cmp == null) siftDownComparable(0, x, array, n); else siftDownUsingComparator(0, x, array, n, cmp); size = n; return result; &#125;&#125;private static &lt;T&gt; void siftDownComparable(int k, T x, Object[] array, int n) &#123; if (n &gt; 0) &#123; Comparable&lt;? super T&gt; key = (Comparable&lt;? super T&gt;)x; int half = n &gt;&gt;&gt; 1; // loop while a non-leaf while (k &lt; half) &#123; int child = (k &lt;&lt; 1) + 1; // assume left child is least Object c = array[child]; int right = child + 1; if (right &lt; n &amp;&amp; ((Comparable&lt;? super T&gt;) c).compareTo((T) array[right]) &gt; 0) c = array[child = right]; if (key.compareTo((T) c) &lt;= 0) break; array[k] = c; k = child; &#125; array[k] = key; &#125;&#125;private static &lt;T&gt; void siftDownUsingComparator(int k, T x, Object[] array, int n, Comparator&lt;? super T&gt; cmp) &#123; if (n &gt; 0) &#123; int half = n &gt;&gt;&gt; 1; while (k &lt; half) &#123; int child = (k &lt;&lt; 1) + 1; Object c = array[child]; int right = child + 1; if (right &lt; n &amp;&amp; cmp.compare((T) c, (T) array[right]) &gt; 0) c = array[child = right]; if (cmp.compare(x, (T) c) &lt;= 0) break; array[k] = c; k = child; &#125; array[k] = x; &#125;&#125; 总结 PriorityBlockingQueue的出入队过程与PriorityQueue基本保持一致 PriorityBlockingQueue使用一个锁和一个notEmpty条件控制并发安全 PriorityBlockingQueue扩容时使用CAS保证只有一个线程进行扩容操作]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
  </entry>
  <entry>
    <title><![CDATA[LinkedBlockingQueue]]></title>
    <url>%2FJava%E9%9B%86%E5%90%88%2FLinkedBlockingQueue%2F</url>
    <content type="text"><![CDATA[LinkedBlockingQueue是一个基于单链表实现的阻塞队列，通过构造器参数可以设定队列容量的大小，如果没有设定默认为Integer.MAX_VALUE,队列中元素顺序遵循FIFO先进先出的规则。 基本属性12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758/** * Linked list node class */ static class Node&lt;E&gt; &#123; E item; /** * 当前节点的后继节点 */ Node&lt;E&gt; next; Node(E x) &#123; item = x; &#125; &#125; /** The capacity bound, or Integer.MAX_VALUE if none */ private final int capacity;//队列容量大小 /** Current number of elements */ private final AtomicInteger count = new AtomicInteger();//元素数量 /** * Head of linked list. * Invariant: head.item == null */ transient Node&lt;E&gt; head;//链表头节点 /** * Tail of linked list. * Invariant: last.next == null */ private transient Node&lt;E&gt; last;//链表尾结点 /** Lock held by take, poll, etc */ private final ReentrantLock takeLock = new ReentrantLock(); /** Wait queue for waiting takes */ private final Condition notEmpty = takeLock.newCondition(); /** Lock held by put, offer, etc */ private final ReentrantLock putLock = new ReentrantLock(); /** Wait queue for waiting puts */ private final Condition notFull = putLock.newCondition(); public LinkedBlockingQueue() &#123; this(Integer.MAX_VALUE); &#125; /** * Creates a &#123;@code LinkedBlockingQueue&#125; with the given (fixed) capacity. * * @param capacity the capacity of this queue * @throws IllegalArgumentException if &#123;@code capacity&#125; is not greater * than zero */ public LinkedBlockingQueue(int capacity) &#123; if (capacity &lt;= 0) throw new IllegalArgumentException(); this.capacity = capacity; last = head = new Node&lt;E&gt;(null); &#125; 入队12345678910111213141516171819202122232425262728293031323334353637public void put(E e) throws InterruptedException &#123; if (e == null) throw new NullPointerException(); // Note: convention in all put/take/etc is to preset local var // holding count negative to indicate failure unless set. int c = -1; Node&lt;E&gt; node = new Node&lt;E&gt;(e); final ReentrantLock putLock = this.putLock; final AtomicInteger count = this.count; putLock.lockInterruptibly(); try &#123; /* * Note that count is used in wait guard even though it is * not protected by lock. This works because count can * only decrease at this point (all other puts are shut * out by lock), and we (or some other waiting put) are * signalled if it ever changes from capacity. Similarly * for all other uses of count in other wait guards. */ while (count.get() == capacity) &#123; notFull.await(); &#125; enqueue(node); c = count.getAndIncrement(); if (c + 1 &lt; capacity) notFull.signal(); &#125; finally &#123; putLock.unlock(); &#125; if (c == 0) signalNotEmpty();&#125;private void enqueue(Node&lt;E&gt; node) &#123; // assert putLock.isHeldByCurrentThread(); // assert last.next == null; last = last.next = node;&#125; 出队1234567891011121314151617181920212223242526272829303132333435363738public E take() throws InterruptedException &#123; E x; int c = -1; final AtomicInteger count = this.count; final ReentrantLock takeLock = this.takeLock; takeLock.lockInterruptibly(); try &#123; while (count.get() == 0) &#123; notEmpty.await(); &#125; x = dequeue(); c = count.getAndDecrement(); if (c &gt; 1) notEmpty.signal(); &#125; finally &#123; takeLock.unlock(); &#125; if (c == capacity) signalNotFull(); return x;&#125;/** * 移除队头元素 head节点不存储数据 * head节点移除后将后继节点设置为head * 并将其item置空 并返回 */private E dequeue() &#123; // assert takeLock.isHeldByCurrentThread(); // assert head.item == null; Node&lt;E&gt; h = head; Node&lt;E&gt; first = h.next; h.next = h; // help GC head = first; E x = first.item; first.item = null; return x;&#125; 总结相比于ArrayBlockingQueueLinkedBlockingQueue出队和入队操作分别使用不同的锁 避免了相互阻塞的现象;ArrayBlockingQueue出入队使用的是同一把锁 出入队会互相阻塞 效率低下两者都是有界队列，若队列长度固定 出队速度小于入队速度 会导致大量线程阻塞LinkedBlockingQueue初始化时如果不指定容量，默认为Integer.MAX_VALUE，若出队速度小于入队速度 会导致队列特别长 占用大量内存]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[PriorityQueue]]></title>
    <url>%2FJava%E9%9B%86%E5%90%88%2FPriorityQueue%2F</url>
    <content type="text"><![CDATA[PriorityQueue是一个基于小顶堆的无界队列，非线程安全，内部元素无序，只有顶部存储着最小的元素；入队是堆的插入元素实现，出队是堆的删除元素实现。 主要属性1234567891011121314151617181920212223public class PriorityQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements java.io.Serializable &#123; private static final long serialVersionUID = -7720805057305804111L; //默认容量 private static final int DEFAULT_INITIAL_CAPACITY = 11; /** * 存放数据的地方 * 优先队列由一个平衡二叉堆来实现：queue[n]的两个子节点分别为queue[2*n+1]和queue[2*n+2] * 其队列中元素的顺序根据构造器传入的comparator保证或者元素的自然顺序 */ transient Object[] queue; // non-private to simplify nested class access /** * 优先队列中元素个数 */ private int size = 0; /** * 比较器 如果为空 则使用元素的自然顺序 */ private final Comparator&lt;? super E&gt; comparator; /** * 修改次数 */ transient int modCount = 0; // non-private to simplify nested class access 入队1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465public boolean add(E e) &#123; return offer(e);&#125;public boolean offer(E e) &#123; if (e == null) throw new NullPointerException(); modCount++; int i = size; if (i &gt;= queue.length)//当元素个数到达容量上限 则进行扩容操作 grow(i + 1); size = i + 1; if (i == 0)//如果还没有元素 queue[0] = e; else siftUp(i, e); return true;&#125;/** * 扩容操作 * 如果旧容量&lt;64 则扩容翻倍 * 如果旧容量&gt;=64 则扩容原来容量的一半 */private void grow(int minCapacity) &#123; int oldCapacity = queue.length; // Double size if small; else grow by 50% int newCapacity = oldCapacity + ((oldCapacity &lt; 64) ? (oldCapacity + 2) : (oldCapacity &gt;&gt; 1)); // overflow-conscious code if (newCapacity - MAX_ARRAY_SIZE &gt; 0) newCapacity = hugeCapacity(minCapacity); queue = Arrays.copyOf(queue, newCapacity);&#125; private void siftUp(int k, E x) &#123; if (comparator != null) siftUpUsingComparator(k, x); else siftUpComparable(k, x);&#125;private void siftUpUsingComparator(int k, E x) &#123; while (k &gt; 0) &#123; //找到节点k的父节点 int parent = (k - 1) &gt;&gt;&gt; 1; Object e = queue[parent]; //插入节点比父节点大则跳出循环 if (comparator.compare(x, (E) e) &gt;= 0) break; queue[k] = e;//与父节点交互 k = parent;//继续与父节点比较 &#125; queue[k] = x;//找到最终的位置 放入数据&#125;private void siftUpComparable(int k, E x) &#123; Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;) x; while (k &gt; 0) &#123; int parent = (k - 1) &gt;&gt;&gt; 1; Object e = queue[parent]; if (key.compareTo((E) e) &gt;= 0) break; queue[k] = e; k = parent; &#125; queue[k] = key;&#125; 出队123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263public E remove() &#123; E x = poll(); if (x != null) return x; else throw new NoSuchElementException();&#125;public E poll() &#123; if (size == 0) return null; int s = --size; modCount++; E result = (E) queue[0]; E x = (E) queue[s]; queue[s] = null; if (s != 0) siftDown(0, x); return result;&#125;private void siftDown(int k, E x) &#123; if (comparator != null) siftDownUsingComparator(k, x); else siftDownComparable(k, x);&#125;private void siftDownComparable(int k, E x) &#123; Comparable&lt;? super E&gt; key = (Comparable&lt;? super E&gt;)x; //只需比较一半即可 因为叶子节点占了一半元素 int half = size &gt;&gt;&gt; 1; // loop while a non-leaf while (k &lt; half) &#123; int child = (k &lt;&lt; 1) + 1; // assume left child is least Object c = queue[child]; int right = child + 1; if (right &lt; size &amp;&amp; ((Comparable&lt;? super E&gt;) c).compareTo((E) queue[right]) &gt; 0) c = queue[child = right]; //如果当前元素比左右子节点还小 跳出循环 if (key.compareTo((E) c) &lt;= 0) break; queue[k] = c; k = child; &#125; //找到正确的位置 放入元素 queue[k] = key;&#125;private void siftDownUsingComparator(int k, E x) &#123; int half = size &gt;&gt;&gt; 1; while (k &lt; half) &#123; int child = (k &lt;&lt; 1) + 1; Object c = queue[child]; int right = child + 1; if (right &lt; size &amp;&amp; comparator.compare((E) c, (E) queue[right]) &gt; 0) c = queue[child = right]; if (comparator.compare(x, (E) c) &lt;= 0) break; queue[k] = c; k = child; &#125; queue[k] = x;&#125;]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ArrayBlockingQueue]]></title>
    <url>%2FJava%E9%9B%86%E5%90%88%2FArrayBlockingQueue%2F</url>
    <content type="text"><![CDATA[ArrayBlockingQueue是由数组实现的有界阻塞队列，数据遵循FIFO先进先出的顺序，一旦创建容量固定无法修改。尝试put一个元素到满队列则阻塞等待，尝试take一个元素到满队列亦阻塞等待。支持可选的公平策略控制等待的生产者和消费者获取数据的顺序，默认顺序是无法保证的。public ArrayBlockingQueue(int capacity, boolean fair)通过构造函数将fair设置为true能保证线程访问的顺序按照FIFO，这种模式下会降低吞吐量但也能减少可变性、避免饥饿。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556public class ArrayBlockingQueue&lt;E&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt;, java.io.Serializable &#123; /** * Serialization ID. This class relies on default serialization * even for the items array, which is default-serialized, even if * it is empty. Otherwise it could not be declared final, which is * necessary here. */ private static final long serialVersionUID = -817911632652898426L; /** The queued items */ final Object[] items; /** items index for next take, poll, peek or remove */ int takeIndex; /** items index for next put, offer, or add */ int putIndex; /** Number of elements in the queue */ int count; /* * Concurrency control uses the classic two-condition algorithm * found in any textbook. */ /** Main lock guarding all access */ final ReentrantLock lock;//控制线程的数据访问顺序 /** Condition for waiting takes */ private final Condition notEmpty;//条件等待：消费者等待获取数据 /** Condition for waiting puts */ private final Condition notFull;//条件等待：生产者等待放入数据 ... .../** * Creates an &#123;@code ArrayBlockingQueue&#125; with the given (fixed) * capacity and the specified access policy. * * @param capacity the capacity of this queue * @param fair if &#123;@code true&#125; then queue accesses for threads blocked * on insertion or removal, are processed in FIFO order; * if &#123;@code false&#125; the access order is unspecified. * @throws IllegalArgumentException if &#123;@code capacity &lt; 1&#125; */public ArrayBlockingQueue(int capacity, boolean fair) &#123; if (capacity &lt;= 0) throw new IllegalArgumentException(); this.items = new Object[capacity]; lock = new ReentrantLock(fair); notEmpty = lock.newCondition(); notFull = lock.newCondition();&#125;]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DelayQueue]]></title>
    <url>%2FJava%E9%9B%86%E5%90%88%2FDelayQueue%2F</url>
    <content type="text"><![CDATA[DelayQueue是一个无界阻塞队列，其元素实现了Delayed接口，其内部实际是使用了PriorityQueue来实现数据的存储。 主要属性123456public class DelayQueue&lt;E extends Delayed&gt; extends AbstractQueue&lt;E&gt; implements BlockingQueue&lt;E&gt; &#123; private final transient ReentrantLock lock = new ReentrantLock(); private final PriorityQueue&lt;E&gt; q = new PriorityQueue&lt;E&gt;(); private Thread leader = null; private final Condition available = lock.newCondition(); 构造器1234public DelayQueue() &#123;&#125;public DelayQueue(Collection&lt;? extends E&gt; c) &#123; this.addAll(c);&#125; 入队1234567891011121314151617181920public boolean add(E e) &#123; return offer(e);&#125;public void put(E e) &#123; offer(e);&#125;public boolean offer(E e) &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; q.offer(e); if (q.peek() == e) &#123; leader = null; available.signal(); &#125; return true; &#125; finally &#123; lock.unlock(); &#125;&#125; 出队1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253public E remove() &#123; E x = poll(); if (x != null) return x; else throw new NoSuchElementException();&#125;public E poll() &#123; final ReentrantLock lock = this.lock; lock.lock(); try &#123; E first = q.peek(); if (first == null || first.getDelay(NANOSECONDS) &gt; 0) return null; else return q.poll(); &#125; finally &#123; lock.unlock(); &#125;&#125;public E take() throws InterruptedException &#123; final ReentrantLock lock = this.lock; lock.lockInterruptibly(); try &#123; for (;;) &#123; E first = q.peek(); if (first == null) available.await(); else &#123; long delay = first.getDelay(NANOSECONDS); if (delay &lt;= 0) return q.poll(); first = null; // don't retain ref while waiting if (leader != null) available.await(); else &#123; Thread thisThread = Thread.currentThread(); leader = thisThread; try &#123; available.awaitNanos(delay); &#125; finally &#123; if (leader == thisThread) leader = null; &#125; &#125; &#125; &#125; &#125; finally &#123; if (leader == null &amp;&amp; q.peek() != null) available.signal(); lock.unlock(); &#125;&#125; 总结 DelayQueue使用重入锁和条件控制来控制并发操作，内部使用优先级队列，常用于定时任务。 Java定时任务线程池ScheduledThreadPoolExecutor内部使用的是自己封装的DelayedWorkQueue（使用数组实现了一遍优先级队列 本质没有区别）]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[SynchronousQueue]]></title>
    <url>%2FJava%E9%9B%86%E5%90%88%2FSynchronousQueue%2F</url>
    <content type="text"><![CDATA[SynchronousQueue实现了BlockingQueue接口的阻塞队列，比较常见的使用场景就是Executors.newCachedThreadPool(),下面有个简单的例子来看看其具体使用吧： 举个栗子123456789101112131415161718192021222324252627SynchronousQueue&lt;Integer&gt; queue = new SynchronousQueue&lt;&gt;(); new Thread(() -&gt; &#123; IntStream.range(1,10).forEach(val-&gt;&#123; try &#123; System.out.println("thread1 put number :" + val); queue.put(val); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;); &#125;).start(); try &#123; Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; new Thread(() -&gt; &#123; try &#123; while (true) System.out.println("thread2 take number:" + queue.take()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;).start(); 输出结果：123456789101112131415161718thread1 put number :1thread2 take number:1thread1 put number :2thread2 take number:2thread1 put number :3thread2 take number:3thread1 put number :4thread2 take number:4thread1 put number :5thread2 take number:5thread1 put number :6thread2 take number:6thread1 put number :7thread1 put number :8thread2 take number:7thread2 take number:8thread1 put number :9thread2 take number:9 可以看到put和take操作是成对出现，实际SynchronousQueue队列中的put&amp;take/offer&amp;poll操作都是互斥等待关系，相当于生产者和消费者，生产者生产出数据无消费者消费则阻塞等待 反之亦然。通过阅读其源码可以看出，SynchronousQueue实际是通过CAS来完成无锁的并发生产、消费。 1234public SynchronousQueue(boolean fair) &#123;//fair为true表示公平模式 通过Dual Queue来实现 false表示非公平模式 通过Dual Stack来实现 transferer = fair ? new TransferQueue&lt;E&gt;() : new TransferStack&lt;E&gt;();&#125; 双重数据结构这里有一个新的概念，dual queue和dual stack称之为dual data structure 译为双重数据结构。什么是双重数据结构？放取数据使用同一个数据结构，其中节点具有两种模式： 数据节点 非数据节点以双重队列为例：放/取元素时先跟队列尾部节点对比，若尾结点跟当前节点是同一模式 则将节点放入尾部入队 如果是互补模式 则将元素匹配并出队列 TransfererTransferQueue和TransferStack继承了Transferer，Transferer是SynchronousQueue的内部类，它提供了一个transfer()方法，该方法定义了转移数据的规范：12345678910111213abstract static class Transferer&lt;E&gt; &#123; /** * 执行put或take操作 * * @param e 不为空时表示交给消费者消费, the item to be handed to a consumer; * 为空时表示请求返回一个生产者提供的数据 * @param timed 是否超时 * @param nanos 超时纳秒数 * @return 如果非空表示数据被提供或收到数据 * 如果未空 可能由于超时或线程中断导致操作失败 可以通过Thread.interrupted判断具体是哪个原因 */ abstract E transfer(E e, boolean timed, long nanos);&#125; 公平模式存储数据结构公平模式是使用双端队列来实现：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106/** Dual Queue */ static final class TransferQueue&lt;E&gt; extends Transferer&lt;E&gt; &#123; /** Node class for TransferQueue. */ static final class QNode &#123; volatile QNode next; // 队列中下一个节点 volatile Object item; // 节点中保存的数据 volatile Thread waiter; // 等待在该节点上的线程 final boolean isData;//判断当前节点是生产者产生还是消费者产生 QNode(Object item, boolean isData) &#123; this.item = item; this.isData = isData; &#125; boolean casNext(QNode cmp, QNode val) &#123; return next == cmp &amp;&amp; UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val); &#125; boolean casItem(Object cmp, Object val) &#123; return item == cmp &amp;&amp; UNSAFE.compareAndSwapObject(this, itemOffset, cmp, val); &#125; /** * Tries to cancel by CAS'ing ref to this as item. */ void tryCancel(Object cmp) &#123; UNSAFE.compareAndSwapObject(this, itemOffset, cmp, this); &#125; /** * 节点被取消执行tryCancel操作 会将节点的item值指向本身 */ boolean isCancelled() &#123; return item == this; &#125; /** * 判断当前节点是否被丢弃 advanceHead操作会将next指向自身 */ boolean isOffList() &#123; return next == this; &#125; // Unsafe mechanics private static final sun.misc.Unsafe UNSAFE; private static final long itemOffset; private static final long nextOffset; static &#123; try &#123; UNSAFE = sun.misc.Unsafe.getUnsafe(); Class&lt;?&gt; k = QNode.class; itemOffset = UNSAFE.objectFieldOffset (k.getDeclaredField("item")); nextOffset = UNSAFE.objectFieldOffset (k.getDeclaredField("next")); &#125; catch (Exception e) &#123; throw new Error(e); &#125; &#125; &#125; /** Head of queue */ transient volatile QNode head; /** Tail of queue */ transient volatile QNode tail; /** * Reference to a cancelled node that might not yet have been * unlinked from queue because it was the last inserted node * when it was cancelled. */ transient volatile QNode cleanMe; TransferQueue() &#123; QNode h = new QNode(null, false); // initialize to dummy node. head = h; tail = h; &#125; /** * Tries to cas nh as new head; if successful, unlink * old head's next node to avoid garbage retention. */ void advanceHead(QNode h, QNode nh) &#123; if (h == head &amp;&amp; UNSAFE.compareAndSwapObject(this, headOffset, h, nh)) h.next = h; // forget old next &#125; /** * Tries to cas nt as new tail. */ void advanceTail(QNode t, QNode nt) &#123; if (tail == t) UNSAFE.compareAndSwapObject(this, tailOffset, t, nt); &#125; /** * Tries to CAS cleanMe slot. */ boolean casCleanMe(QNode cmp, QNode val) &#123; return cleanMe == cmp &amp;&amp; UNSAFE.compareAndSwapObject(this, cleanMeOffset, cmp, val); &#125;可以看出TransferQueue是通过QNode封装线程作为节点的普通的双端队列，QNode的next指向队列中的下一个节点，TransferQueue分别有一个指向队列头部(head)和尾部(tail)的指针。TransferQueue有三个重要的方法，transfer、awaitFulfill和clean,其中transfer是put/take/offer/poll方法的实际实现。 transfer123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475public void put(E e) throws InterruptedException &#123; if (e == null) throw new NullPointerException(); if (transferer.transfer(e, false, 0) == null) &#123; Thread.interrupted(); throw new InterruptedException(); &#125;&#125;TransferQueue() &#123; QNode h = new QNode(null, false); // initialize to dummy node. head = h; tail = h;&#125; E transfer(E e, boolean timed, long nanos) &#123; QNode s = null; // constructed/reused as needed boolean isData = (e != null); for (;;) &#123; QNode t = tail; QNode h = head; if (t == null || h == null) // 并发操作 未完成初始化 则自旋 continue; // spin if (h == t || t.isData == isData) &#123; // 队列为空 或 E和队尾元素具有相同模式 QNode tn = t.next; if (t != tail) // inconsistent read 非一致读 状态不一致表示其他线程修改了tail 自旋 continue; if (tn != null) &#123; // lagging tail 如果队尾后扔挂着元素表明其他线程添加了节点 将tail进行cas操作更新 尝试将tn设置为tail advanceTail(t, tn); continue; &#125; if (timed &amp;&amp; nanos &lt;= 0) // 调用超时 直接返回null return null; if (s == null) s = new QNode(e, isData); if (!t.casNext(null, s)) // put的元素先加在tail的next指针上 失败则自旋 continue; advanceTail(t, s); // swing tail and wait 通过CAS更新tail Object x = awaitFulfill(s, e, timed, nanos); if (x == s) &#123; // x等于s 表明节点中断或超时 否则s==null或是匹配的节点 clean(t, s);//清理节点s return null; &#125; if (!s.isOffList()) &#123; // 判断节点是否已经从队列中离开 advanceHead(t, s); // 尝试将s节点设置为head 移出t if (x != null) // and forget fields s.item = s; s.waiter = null;//释放线程ref &#125; return (x != null) ? (E)x : e; &#125; else &#123; // complementary-mode QNode m = h.next; // node to fulfill if (t != tail || m == null || h != head)//其他线程修改了结构 不一致读 自旋重新开始 continue; // inconsistent read /** * 生产者和消费者匹配操作 */ Object x = m.item; if (isData == (x != null) || // 判断isData与x的模式是否相同 相同表示匹配了 x == m || // m节点被取消了 !m.casItem(x, e)) &#123; // 尝试将数据e设置到m上失败 advanceHead(h, m); // 将m设置为头节点 h出队列 然后重试 continue; &#125; advanceHead(h, m); // 成功匹配 m设置为头节点 h出队列 LockSupport.unpark(m.waiter); return (x != null) ? (E)x : e; &#125; &#125;&#125; transfer方法主要完成两个工作： 当队列为空或者加入节点和尾结点具有相同模式，则将节点追加到尾部 等待匹配成功返回值或者被取消返回null 当前节点与头节点是互补模式，则通过CAS尝试完成匹配 唤醒节点并移除队列 返回匹配的值 awaitFulfill1234567891011121314151617181920212223242526272829303132333435/** * 自旋或阻塞直到节点s被填充 * 如果s为head.next节点，则进行自旋 * 否则直接block 直到有其他线程与之匹配或其自己进行线程中断 */Object awaitFulfill(QNode s, E e, boolean timed, long nanos) &#123; /* Same idea as TransferStack.awaitFulfill */ final long deadline = timed ? System.nanoTime() + nanos : 0L; Thread w = Thread.currentThread(); //计算自旋次数 前提s位于头结点的下一个节点 如果设置了等待时间 自旋次数为32 如果未设置时间 自旋次数为512 int spins = ((head.next == s) ? (timed ? maxTimedSpins : maxUntimedSpins) : 0); for (;;) &#123; if (w.isInterrupted())//线程被中断 则取消节点：将item字段指向自己 s.tryCancel(e); Object x = s.item; if (x != e)//跳出自旋 1、线程被中断 2、等待时间到了被取消 3、线程拿走数据并修改了item的值 return x; if (timed) &#123; nanos = deadline - System.nanoTime(); if (nanos &lt;= 0L) &#123;//超过等待时间 取消节点(通过将自身item指向自己 if(x!=e)肯定成立) s.tryCancel(e); continue; &#125; &#125; if (spins &gt; 0)//自旋次数&gt;0 自减一 --spins; else if (s.waiter == null) s.waiter = w; else if (!timed)//没有超时时间的park LockSupport.park(this); else if (nanos &gt; spinForTimeoutThreshold)//自旋次数耗尽 超时时间的park LockSupport.parkNanos(this, nanos); &#125;&#125; clean12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364/** * 清理掉被取消的节点 */void clean(QNode pred, QNode s) &#123; s.waiter = null; // forget thread /* * At any given time, exactly one node on list cannot be * deleted -- the last inserted node. To accommodate this, * if we cannot delete s, we save its predecessor as * "cleanMe", deleting the previously saved version * first. At least one of node s or the node previously * saved can always be deleted, so this always terminates. */ while (pred.next == s) &#123; // Return early if already unlinked QNode h = head; QNode hn = h.next; // Absorb cancelled first node as head //如果hn不会空并且被取消 向前推进 if (hn != null &amp;&amp; hn.isCancelled()) &#123; advanceHead(h, hn); continue; &#125; QNode t = tail; // Ensure consistent read for tail //队列为空 if (t == h) return; QNode tn = t.next; //读不一致 重新开始 if (t != tail) continue; //tn不为空表示其他线程新增了节点 cas更新tail 重新开始 if (tn != null) &#123; advanceTail(t, tn); continue; &#125; //s不是尾节点 移出队列 if (s != t) &#123; // If not tail, try to unsplice QNode sn = s.next; //如果s已经移出队列退出循环 否则尝试断开 if (sn == s || pred.casNext(s, sn)) return; &#125; /** * s为尾节点 则有可能其他线程在添加新节点 则cleanMe登场 **/ QNode dp = cleanMe; //如果dp不为null 说明是前一个被取消的节点 将其移除 if (dp != null) &#123; // Try unlinking previous cancelled node QNode d = dp.next; QNode dn; if (d == null || // 节点d已经删除 d == dp || // 原来的节点cleanMe已经通过advanceHead进行删除 !d.isCancelled() || // d not cancelled or (d != t &amp;&amp; // d not tail and (dn = d.next) != null &amp;&amp; // has successor dn != d &amp;&amp; // that is on list dp.casNext(d, dn))) // d unspliced //清除cleanMe节点 如果dp == pred成立，则说明节点s清除成功直接return 否则要再次循环 casCleanMe(dp, null); if (dp == pred) return; // s is already saved node &#125; else if (casCleanMe(null, pred))//先将要删除的尾部节点标记为cleanMe 延迟等待下次删除 return; // Postpone cleaning s &#125;&#125; clean方法的思路分两种情况： 若被取消的节点不是队列尾部节点 则直接通过修改其前驱节点的next指针指向其后继节点，将被取消的节点删除 若被取消的节点是队列的尾部节点 则用cleanMe指针指向其前驱节点，等待以后再删除（只要为了防止我们在删除尾部节点的同时有其他节点被追加到尾部节点） 当cleanMe==null时将前继节点pred设置为cleanMe为下次删除做准备当cleanMe!=null时先删除上次需要删除的cleanMe.next然后将cleanMe置为null 然后再讲pred赋值给cleanMe clean方法源码因为并发的情况比较多 理解起来有些难度 可以参考戳我~ 非公平模式存储数据结构123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113/** Dual stack */static final class TransferStack&lt;E&gt; extends Transferer&lt;E&gt; &#123;/* * This extends Scherer-Scott dual stack algorithm, differing, * among other ways, by using "covering" nodes rather than * bit-marked pointers: Fulfilling operations push on marker * nodes (with FULFILLING bit set in mode) to reserve a spot * to match a waiting node. *//* Modes for SNodes, ORed together in node fields *//** Node represents an unfulfilled consumer */static final int REQUEST = 0;//消费者请求数据/** Node represents an unfulfilled producer */static final int DATA = 1;//生产者生产数据/** Node is fulfilling another unfulfilled DATA or REQUEST */static final int FULFILLING = 2;//正在匹配中/** Returns true if m has fulfilling bit set. */static boolean isFulfilling(int m) &#123; return (m &amp; FULFILLING) != 0; &#125;/** Node class for TransferStacks. */static final class SNode &#123; volatile SNode next; // 指向栈中下一个节点 volatile SNode match; // the node matched to this volatile Thread waiter; // 等待在节点上的线程 Object item; // 节点上存储的数据 data; or null for REQUESTs int mode; // Note: item and mode fields don't need to be volatile // since they are always written before, and read after, // other volatile/atomic operations. SNode(Object item) &#123; this.item = item; &#125; boolean casNext(SNode cmp, SNode val) &#123; return cmp == next &amp;&amp; UNSAFE.compareAndSwapObject(this, nextOffset, cmp, val); &#125; /** * Tries to match node s to this node, if so, waking up thread. * Fulfillers call tryMatch to identify their waiters. * Waiters block until they have been matched. * * @param s the node to match * @return true if successfully matched to s */ boolean tryMatch(SNode s) &#123; if (match == null &amp;&amp; UNSAFE.compareAndSwapObject(this, matchOffset, null, s)) &#123; Thread w = waiter; if (w != null) &#123; // waiters need at most one unpark waiter = null; LockSupport.unpark(w); &#125; return true; &#125; return match == s; &#125; /** * Tries to cancel a wait by matching node to itself. */ void tryCancel() &#123; UNSAFE.compareAndSwapObject(this, matchOffset, null, this); &#125; boolean isCancelled() &#123; return match == this; &#125; // Unsafe mechanics private static final sun.misc.Unsafe UNSAFE; private static final long matchOffset; private static final long nextOffset; static &#123; try &#123; UNSAFE = sun.misc.Unsafe.getUnsafe(); Class&lt;?&gt; k = SNode.class; matchOffset = UNSAFE.objectFieldOffset (k.getDeclaredField("match")); nextOffset = UNSAFE.objectFieldOffset (k.getDeclaredField("next")); &#125; catch (Exception e) &#123; throw new Error(e); &#125; &#125;&#125;/** The head (top) of the stack */volatile SNode head;//指向栈顶 并且没有初始化为dummy节点boolean casHead(SNode h, SNode nh) &#123; return h == head &amp;&amp; UNSAFE.compareAndSwapObject(this, headOffset, h, nh);&#125;/** * Creates or resets fields of a node. Called only from transfer * where the node to push on stack is lazily created and * reused when possible to help reduce intervals between reads * and CASes of head and to avoid surges of garbage when CASes * to push nodes fail due to contention. */static SNode snode(SNode s, Object e, SNode next, int mode) &#123; if (s == null) s = new SNode(e); s.mode = mode; s.next = next; return s;&#125; TransferStack是一个栈结构，使用SNode来封装栈节点，包含一个用于指向栈顶的指针head,其内部与TransferQueue基本相同，不同在于：TransferStack在匹配到节点时不是将节点立即出栈而是将匹配节点入栈 然后同时将匹配上的两个节点一起出栈 tranfertranfer的基本算法为： 若栈为空或head节点与当前节点模式相同（均为REQUEST或DATA）则尝试将节点加入栈并等待匹配，匹配成功返回相应的值 若被取消则返回null 若栈中包含互补模式的节点，则尝试入栈一个包含FULFILLING的节点 并且匹配相应的处于等待中的栈中节点，匹配成功将成功匹配的两个节点都出栈并返回相应的值 若栈顶为一个模式包含FULFILLING的节点，则帮助其执行匹配和出栈操作，然后再循环执行自己的匹配操作。帮助其他线程操作和自身执行匹配操作代码基本一致，除了不返回匹配的值。12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091E transfer(E e, boolean timed, long nanos) &#123; SNode s = null; // constructed/reused as needed int mode = (e == null) ? REQUEST : DATA; for (;;) &#123; SNode h = head; //如果栈为空或者当前节点模式和head结点模式相同 将节点压入栈内 等待匹配 if (h == null || h.mode == mode) &#123; // empty or same-mode //超时 if (timed &amp;&amp; nanos &lt;= 0) &#123; // can't wait if (h != null &amp;&amp; h.isCancelled())//节点被取消 casHead(h, h.next); // 清除被取消的节点 else return null; //非超时 实例化一个SNode节点 并通过CAS尝试替换头结点head(head-&gt;s-&gt;h) &#125; else if (casHead(h, s = snode(s, e, h, mode))) &#123; //自旋等待线程匹配 SNode m = awaitFulfill(s, timed, nanos); if (m == s) &#123; // wait was cancelled clean(s); return null; &#125; /** * 运行到这里说明得到匹配被唤醒 从栈顶将匹配的两个节点一起出栈 */ if ((h = head) != null &amp;&amp; h.next == s) casHead(h, s.next); // help s's fulfiller return (E) ((mode == REQUEST) ? m.item : s.item); &#125; &#125; else if (!isFulfilling(h.mode)) &#123; // try to fulfill 模式不同 尝试匹配 if (h.isCancelled()) // already cancelled casHead(h, h.next); // pop and retry //将节点入栈，且模式标记为正在匹配中 else if (casHead(h, s=snode(s, e, h, FULFILLING|mode))) &#123; for (;;) &#123; // loop until matched or waiters disappear SNode m = s.next; // m is s's match if (m == null) &#123; // all waiters are gone 说明栈中s之后无元素了 重新进入最外层循环 casHead(s, null); // pop fulfill node s = null; // use new node next time break; // restart main loop &#125; /** * 将s设置为m的匹配节点 并更新栈顶为m.next 即将s和m同时出栈 */ SNode mn = m.next; if (m.tryMatch(s)) &#123; casHead(s, mn); // pop both s and m return (E) ((mode == REQUEST) ? m.item : s.item); &#125; else // lost match s.casNext(m, mn); // help unlink &#125; &#125; /** * 如果其他线程正在匹配 则帮助其匹配 */ &#125; else &#123; // help a fulfiller SNode m = h.next; // m is h's match if (m == null) // waiter is gone casHead(h, null); // pop fulfilling node else &#123; SNode mn = m.next; if (m.tryMatch(h)) // help match casHead(h, mn); // pop both h and m else // lost match h.casNext(m, mn); // help unlink &#125; &#125; &#125;&#125;/** * Tries to match node s to this node, if so, waking up thread. * Fulfillers call tryMatch to identify their waiters. * Waiters block until they have been matched. * * @param s the node to match * @return true if successfully matched to s */boolean tryMatch(SNode s) &#123; if (match == null &amp;&amp; UNSAFE.compareAndSwapObject(this, matchOffset, null, s)) &#123; Thread w = waiter; if (w != null) &#123; // waiters need at most one unpark waiter = null; LockSupport.unpark(w); &#125; return true; &#125; return match == s;&#125; clean当节点被取消则将节点从栈中移除123456789101112131415161718192021222324252627282930313233343536/** * Unlinks s from the stack. */void clean(SNode s) &#123; s.item = null; // forget item s.waiter = null; // forget thread /* * At worst we may need to traverse entire stack to unlink * s. If there are multiple concurrent calls to clean, we * might not see s if another thread has already removed * it. But we can stop when we see any node known to * follow s. We use s.next unless it too is cancelled, in * which case we try the node one past. We don't check any * further because we don't want to doubly traverse just to * find sentinel. */ SNode past = s.next; if (past != null &amp;&amp; past.isCancelled()) past = past.next; // Absorb cancelled nodes at head SNode p; while ((p = head) != null &amp;&amp; p != past &amp;&amp; p.isCancelled()) casHead(p, p.next); // Unsplice embedded nodes while (p != null &amp;&amp; p != past) &#123; SNode n = p.next; if (n != null &amp;&amp; n.isCancelled()) p.casNext(n, n.next); else p = n; &#125;&#125; 【死磕Java并发】—–J.U.C之阻塞队列：SynchronousQueueSynchronousQueue 源码分析 (基于Java 8)[java1.8源码笔记]SynchronousQueue详解]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java线程状态]]></title>
    <url>%2FJava%E5%B9%B6%E5%8F%91%2FJava%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%2F</url>
    <content type="text"><![CDATA[前言Java Thread类中定义了线程的整个生命周期的不同状态，一个线程在任意特定时刻只有一个状态，这些状态只是虚拟机中的状态并不能反映操作系统实际线程的状态。 线程状态java.lang.Thread.State中共定义了6中状态： NEW：线程只是完成初始化 还没启动 RUNNABLE：线程已经准备就绪，在java虚拟机中表示线程正在执行，但在操作系统层面 线程可能还在等待比如分配CPU或IO等资源。 BLOCKED: 此状态表示线程阻塞等待一个monitor lock进入一个synchronized限定的代码块或方法，或者 线程先进入synchronized限定的方法或代码块，但是调用了wait()方法并释放了获得的锁，等到再次被notify()唤醒 再次阻塞等待进入synchronized限定的代码块或方法中。即：A、B两个线程都需要获取锁来执行方法，A获得锁还未释放，那么B就处于BLOCKED状态 WAITING: 线程调用以下方法进入此状态： Object.wait() 无超时参数 Thread.join() 无超时参数 LockSupport.park() 线程进入此状态，等待另一个线程调用特定方法。例如：一个线程调用Object.wait()等待另一个线程调用Object.notify()或Object.notifyAll();一个线程调用了Thread.join()则等待这个线程执行完毕进入Terminated状态 TIMED_WAITING: 线程调用以下指定等待时间等待线程的方法进入此状态： Thread.sleep() Object.wait() 带超时参数 Thread.join() 带超时参数 LockSupport.parkNanos() LockSupport.parkUntil() TERMINATED: 线程已完成执行进入此状态 小结我们日常工作当中经常会使用jstack命令来分析java的堆栈信息，比如 当我们发现线程长时间处于BLOCKED状态，我们就需要分析下 是不是哪个地方锁没有释放？ 如果线程处于WAITING状态，需要分析下是不是调用Object.wait() LockSupport.park()的地方没有调用notify() LockSupport.unpark() 又或是调用时机不当 学习和深入理解线程状态 对于工作中快速、精准定位问题 jstack是武功招式 线程状态可谓是内功心法。。。 附张截取网络上的线程状态转移图： 函数名 JDK版本 消耗CPU 能否被Interrupt 核心方法 线程状态 备注 Spin Lock 1.0 是 否 native RUNNABLE wait() 1.0 否 是 native WAITING LockSupport.park() 1.5 否 是 native WAITING sleep() 1.0 否 是 native TIMED_WAITING join() 1.0 否 是 wait() WAITING suspend() 1.0 否 否 native WAITING Deprecated ReentrantLock.lock() 1.5 部分是 否 park() WAITING 有可interrupt版本lockInterruptibly() Condition.await() 1.5 否 是 park() WAITING 有不可interrupt版本 awaitUninterruptibly() FutureTask.get() 1.5 否 是 park() WAITING 无]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Concurrent</tag>
        <tag>Thread</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CompletableFuture]]></title>
    <url>%2FJava%E5%B9%B6%E5%8F%91%2FCompletableFuture%2F</url>
    <content type="text"><![CDATA[CompletableFuture是由并发大师Doug Lea编写于JDK8中，可以显式的主动控制任务完成并设置结果和状态，并在任务完成后可以结合CompletionStage提供的接续方法完成相关回调处理。 Completable概述JDK8之前我们使用异步调用：123456789101112131415161718ExecutorService executorService = new ThreadPoolExecutor(4, 10, 2000, TimeUnit.MILLISECONDS, new LinkedBlockingQueue&lt;&gt;(1000));Future&lt;?&gt; result = executorService.submit(() -&gt; &#123; System.out.println("start to make cake..."); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("finished cake..."); return "cake"; &#125;); try &#123; System.out.println(result.get()); System.out.println("I go to drink milk."); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125;JDK8我们使用CompletableFuture:12345678910111213141516171819CompletableFuture.supplyAsync(() -&gt; &#123; System.out.println("start to make cake..."); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("finished cake..."); return "cake";&#125;).thenAccept(cake -&gt; &#123; System.out.println("I eat " + cake);&#125;);System.out.println("I go to drink milk.");try &#123; Thread.currentThread().join();&#125; catch (InterruptedException e) &#123; e.printStackTrace();&#125;代码对比可以看出,JDK5提供的Future提供异步计算结果的能力，通过isDone()方法检查计算是否完成或者get()阻塞调用线程等待计算结果返回，又或者使用cancel()取消任务的执行，虽然Future以及相关使用方法提供了异步执行的能力，但是对于计算结果的获取却很不便利，只能通过轮询或者阻塞方式得到，阻塞的方式显然违背了异步编程的初衷，轮询的方式又会浪费无畏的CPU资源，而且不能及时得到返回结果。JDK8提供了CompletableFuture类，实现了java.util.concurrent.Future和java.util.concurrent.CompletionStage接口，所以我们还可以像以前那样通过阻塞或者轮询的方式获得结果，尽管这种方式不推荐使用。CompletionStage定义了任务执行完成后不同阶段，提供任务执行完成后进行操作的回调,CompletableFuture类中包含了大概50多个方法，但从命名是有规律可循的 用于创建CompletableFuture对象 1234567public CompletableFuture()public static CompletableFuture&lt;Void&gt; allOf(CompletableFuture&lt;?&gt;... cfs)public static CompletableFuture&lt;Object&gt; anyOf(CompletableFuture&lt;?&gt;... cfs)public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable)public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable, Executor executor)public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier)public static &lt;U&gt; CompletableFuture&lt;U&gt; supplyAsync(Supplier&lt;U&gt; supplier, Executor executor) 用于判断当前状态和同步等待取值 123456public T join()public T get(long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutExceptionpublic T getNow(T valueIfAbsent)public boolean isCancelled()public boolean isCompletedExceptionally()public boolean isDone() 用于显示得控制CompletableFuture完成状态 123public boolean complete(T value)public boolean completeExceptionally(Throwable ex)public boolean cancel(boolean mayInterruptIfRunning) CompletableFutre的接续方法，任务完成后的回调 12345678910111213thenApply, thenApplyAsyncthenAccept, thenAcceptAsyncthenRun, thenRunAsyncthenCombine, thenCombineAsyncthenAcceptBoth, thenAcceptBothAsyncrunAfterBoth, runAfterBothAsyncapplyToEither, applyToEitherAsyncacceptEither, acceptEitherAsyncrunAfterEither, runAfterEitherAsyncthenCompose, thenComposeAsyncwhenComplete, whenCompleteAsynchandle, handleAsyncexceptionally 以Async结尾的都是异步方法，如果指定了线程池则使用指定的线程池，否则在默认的ForkJoinPool.commonPool()中执行以run开头的方法，其方法入参的lambda表达式一定是无参数 并且无返回值 即Runnable接口以supply开头的方法，其方法入参的lambda表达式一定是无参数 并有返回值 即Supplier接口以accepet开头或结尾的方法，其方法入参的lambda表达式一定是有参数 并无返回值 即Comsumer接口以apply开头或结尾的方法，其方法入参的lambda表达式一定是有参数并有返回值 即Function接口带有either后缀的表示谁先完成则消费谁 源码分析了解了CompletableFuture的大概用法，我们从runAsync入手看看其执行过程123 public static CompletableFuture&lt;Void&gt; runAsync(Runnable runnable) &#123; return asyncRunStage(asyncPool, runnable);&#125;这里的asyncPool通过判断是否支持并行化 默认使用ForkJoinPool.commonPool() private static final boolean useCommonPool = (ForkJoinPool.getCommonPoolParallelism() &gt; 1);private static final Executor asyncPool = useCommonPool ? ForkJoinPool.commonPool() : new ThreadPerTaskExecutor(); 12345678910111213141516171819202122232425262728293031323334static CompletableFuture&lt;Void&gt; asyncRunStage(Executor e, Runnable f) &#123; if (f == null) throw new NullPointerException(); CompletableFuture&lt;Void&gt; d = new CompletableFuture&lt;Void&gt;(); e.execute(new AsyncRun(d, f)); return d;&#125;@SuppressWarnings("serial") static final class AsyncRun extends ForkJoinTask&lt;Void&gt; implements Runnable, AsynchronousCompletionTask &#123; CompletableFuture&lt;Void&gt; dep; Runnable fn; AsyncRun(CompletableFuture&lt;Void&gt; dep, Runnable fn) &#123; this.dep = dep; this.fn = fn; &#125; public final Void getRawResult() &#123; return null; &#125; public final void setRawResult(Void v) &#123;&#125; public final boolean exec() &#123; run(); return true; &#125; public void run() &#123; CompletableFuture&lt;Void&gt; d; Runnable f; if ((d = dep) != null &amp;&amp; (f = fn) != null) &#123; dep = null; fn = null; if (d.result == null) &#123; try &#123; f.run(); d.completeNull(); &#125; catch (Throwable ex) &#123; d.completeThrowable(ex); &#125; &#125; d.postComplete(); &#125; &#125;&#125;]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Concurrent</tag>
        <tag>Future</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ScheduledThreadPoolExecutor]]></title>
    <url>%2FJava%E5%B9%B6%E5%8F%91%2FScheduledThreadPoolExecutor%2F</url>
    <content type="text"><![CDATA[ScheduledExecutorService简单看下其继承关系的类图如下： ExecutorExecutor定义了一个线程池的最核心的操作execute,帮助我们将任务提交和任务具体执行、调度进行解耦。1void execute(Runnable command);通过Executor而不是现实的创建线程(new Thread(RunnableTask()).start())：1234Executor executor = anExecutor();executor.execute(new RunnableTask1());executor.execute(new RunnableTask2());... ExecutorServiceExecutorService提供方法来管理线程池的关闭、提供Future来追踪一个或多个异步任务的执行进度。ExecutorService可以关闭拒绝新来的任务，其提供了两种关闭方式： shutdown() :关闭前允许之前提交的任务先执行完 shutdownNow():阻止等待的任务并尝试停止正在执行的任务submit()方法通过execute()实现并返回一个Future，可取消任务的执行或等待任务执行完成。invokeAny和invokeAll方法用于批量执行任务，等待至少一个或者全部任务执行完成。123456789101112131415161718void shutdown();List&lt;Runnable&gt; shutdownNow();boolean isShutdown();boolean isTerminated();boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;&lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task);&lt;T&gt; Future&lt;T&gt; submit(Runnable task, T result);Future&lt;?&gt; submit(Runnable task);&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException;&lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException;&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks) throws InterruptedException, ExecutionException;&lt;T&gt; T invokeAny(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks, long timeout, TimeUnit unit) throws InterruptedException, ExecutionException, TimeoutException; ScheduledExecutorServicescheduledExecutorService在ExecutorService的基础上加入了定时任务调度的特性,可以调度任务在给定延时执行或在固定周期内执行。schedule()可创建不同延迟的任务，并返回一个可取消或校验执行的ScheduledFuture&lt;?&gt;对象。scheduledAtFixedRate()和scheduledWithFixedDelay()方法创建周期性任务直达任务取消。 12345678910111213141516171819public ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit);public &lt;V&gt; ScheduledFuture&lt;V&gt; schedule(Callable&lt;V&gt; callable, long delay, TimeUnit unit);/** * initialDelay初始延迟过后 周期性的执行任务 * 如果任务执行时间过长超过执行周期，后来的任务将延迟执行 * 不会并发执行 **/public ScheduledFuture&lt;?&gt; scheduleAtFixedRate(Runnable command, long initialDelay, long period, TimeUnit unit);/** * 同样在initialDelay延迟后，开始周期性执行任务 * 按照前一个任务结束到后一个任务开始的 固定时间间隔执行 **/public ScheduledFuture&lt;?&gt; scheduleWithFixedDelay(Runnable command, long initialDelay, long delay, TimeUnit unit); ScheduledThreadPoolExecutorScheduledThreadPoolExecutor是一个可以设置固定延迟或周期性执行任务的ThreadPoolExecutor。相对于Timer来说，当需要多个工作线程，或需要更加灵活 或需要ThreadPoolExecutor相关功能，ScheduledThreadPoolExecutor会更适合。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206//ScheduledThreadPoolExecutorpublic &lt;T&gt; Future&lt;T&gt; submit(Callable&lt;T&gt; task) &#123; return schedule(task, 0, NANOSECONDS);&#125;public void execute(Runnable command) &#123; schedule(command, 0, NANOSECONDS);&#125;public ScheduledFuture&lt;?&gt; schedule(Runnable command, long delay, TimeUnit unit) &#123; if (command == null || unit == null) throw new NullPointerException(); RunnableScheduledFuture&lt;?&gt; t = decorateTask(command, new ScheduledFutureTask&lt;Void&gt;(command, null, triggerTime(delay, unit))); delayedExecute(t); return t;&#125;private void delayedExecute(RunnableScheduledFuture&lt;?&gt; task) &#123; if (isShutdown()) reject(task); else &#123; //任务先加入DelayedWorkQueue中 通过最小堆排序 确定其执行的时机 super.getQueue().add(task); if (isShutdown() &amp;&amp; !canRunInCurrentRunState(task.isPeriodic()) &amp;&amp; remove(task)) task.cancel(false); else ensurePrestart(); &#125; &#125;//ThreadPoolExecutor/** * 保证线程池即使初始化corePoolSize为0时 也能有线程可供执行任务 */void ensurePrestart() &#123; int wc = workerCountOf(ctl.get()); if (wc &lt; corePoolSize) addWorker(null, true); else if (wc == 0) addWorker(null, false);&#125;private boolean addWorker(Runnable firstTask, boolean core) &#123; retry: for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs &gt;= SHUTDOWN &amp;&amp; ! (rs == SHUTDOWN &amp;&amp; firstTask == null &amp;&amp; ! workQueue.isEmpty())) return false; for (;;) &#123; int wc = workerCountOf(c); if (wc &gt;= CAPACITY || wc &gt;= (core ? corePoolSize : maximumPoolSize)) return false; if (compareAndIncrementWorkerCount(c)) break retry; c = ctl.get(); // Re-read ctl if (runStateOf(c) != rs) continue retry; // else CAS failed due to workerCount change; retry inner loop &#125; &#125; boolean workerStarted = false; boolean workerAdded = false; Worker w = null; try &#123; //任务封装成worker对象 并执行 w = new Worker(firstTask); final Thread t = w.thread; if (t != null) &#123; final ReentrantLock mainLock = this.mainLock; mainLock.lock(); try &#123; // Recheck while holding lock. // Back out on ThreadFactory failure or if // shut down before lock acquired. int rs = runStateOf(ctl.get()); if (rs &lt; SHUTDOWN || (rs == SHUTDOWN &amp;&amp; firstTask == null)) &#123; if (t.isAlive()) // precheck that t is startable throw new IllegalThreadStateException(); workers.add(w); int s = workers.size(); if (s &gt; largestPoolSize) largestPoolSize = s; workerAdded = true; &#125; &#125; finally &#123; mainLock.unlock(); &#125; if (workerAdded) &#123;//任务添加成功则执行任务 t.start(); workerStarted = true; &#125; &#125; &#125; finally &#123; if (! workerStarted) addWorkerFailed(w); &#125; return workerStarted;&#125;//ThreadPoolExecutor$WorkerWorker(Runnable firstTask) &#123; setState(-1); // inhibit interrupts until runWorker this.firstTask = firstTask; this.thread = getThreadFactory().newThread(this);&#125;public void run() &#123; runWorker(this);&#125;final void runWorker(Worker w) &#123; Thread wt = Thread.currentThread(); Runnable task = w.firstTask; w.firstTask = null; w.unlock(); // allow interrupts boolean completedAbruptly = true; try &#123; //关键点： 判断Worker初始化任务是否为null 如果第一次初始化任务完成 则通过getTask方法尝试从BlockingQueue中拉取任务 while (task != null || (task = getTask()) != null) &#123; w.lock(); // If pool is stopping, ensure thread is interrupted; // if not, ensure thread is not interrupted. This // requires a recheck in second case to deal with // shutdownNow race while clearing interrupt if ((runStateAtLeast(ctl.get(), STOP) || (Thread.interrupted() &amp;&amp; runStateAtLeast(ctl.get(), STOP))) &amp;&amp; !wt.isInterrupted()) wt.interrupt(); try &#123; beforeExecute(wt, task); Throwable thrown = null; try &#123; task.run();//Worker包裹的实际任务(FutureTask/ScheduledFutureTask)执行 &#125; catch (RuntimeException x) &#123; thrown = x; throw x; &#125; catch (Error x) &#123; thrown = x; throw x; &#125; catch (Throwable x) &#123; thrown = x; throw new Error(x); &#125; finally &#123; afterExecute(task, thrown); &#125; &#125; finally &#123; task = null; w.completedTasks++; w.unlock(); &#125; &#125; completedAbruptly = false; &#125; finally &#123; processWorkerExit(w, completedAbruptly); &#125;&#125;private Runnable getTask() &#123; boolean timedOut = false; // Did the last poll() time out? for (;;) &#123; int c = ctl.get(); int rs = runStateOf(c); // Check if queue empty only if necessary. if (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123; decrementWorkerCount(); return null; &#125; int wc = workerCountOf(c); // Are workers subject to culling? boolean timed = allowCoreThreadTimeOut || wc &gt; corePoolSize; if ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut)) &amp;&amp; (wc &gt; 1 || workQueue.isEmpty())) &#123; if (compareAndDecrementWorkerCount(c)) return null; continue; &#125; try &#123; //从BlockingQueue中拉取任务 Runnable r = timed ? workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) : workQueue.take(); if (r != null) return r; timedOut = true; &#125; catch (InterruptedException retry) &#123; timedOut = false; &#125; &#125;&#125; 12345678910111213141516//ScheduledThreadPoolExecutor$ScheduledFutureTask/** * 重写了FutureTask的run方法 runAndReset实现周期性任务执行 */public void run() &#123; boolean periodic = isPeriodic(); if (!canRunInCurrentRunState(periodic)) cancel(false); else if (!periodic) ScheduledFutureTask.super.run(); else if (ScheduledFutureTask.super.runAndReset()) &#123; setNextRunTime(); reExecutePeriodic(outerTask); &#125; &#125;&#125; ScheduledThreadPoolExecutor相对于ThreadPoolExecutor，通过将Runnable任务封装为ScheduledFutureTask,内部使用的BlockingQueue为自定义的DelayedWorkQueue来完成固定延迟或周期性调度任务，ScheduledFutureTask其类图如下： DelayedWorkQueue其源码类似于PriorityQueue，核心使用了最小堆来维护数据，加入删除数据时使用siftup和siftDown操作来保证最小堆的正确性。ScheduledThreadPoolExecutor介于此，只需检查最小堆顶部的任务是否达到执行条件即可 故而使用ScheduledThreadPoolExecutor来执行的定时任务 并不是那么准确]]></content>
      <categories>
        <category>Java并发</category>
      </categories>
      <tags>
        <tag>Concurrent</tag>
        <tag>ThreadPool</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java NIO]]></title>
    <url>%2FIO%2FJava-NIO%2F</url>
    <content type="text"><![CDATA[距离上次看nio相关知识想来也快一年了，感觉对于nio的理解总是停留在IO复用的io模型，知其然但不知其所以然，故而今天来解开Java NIO的神秘面纱。首先来回顾下NIO基本概念，Java NIO主要由Buffer、Channel、Selector三大组件组成。其他组件比如Pipe、FileLock只不过是这三个组件的公共工具类。Buffer是与NIO Channel交互的载体，提供了一系列便于操作内存块的方法。读数据是从Channel读取到Buffer中，写数据是从Buffer写入到Channel。使用Buffer进行读写数据通常需要4步：将数据写入到Buffer 调用buffer.flip() 从Buffer中读取数据 调用buffer.clear()或者buffer.compact() TCP/IP 三次握手 Java NIO API基本原理Selector.open -&gt; Pipe.open 创建一个Selector实例 初始化Selector(windows为WindowsSelectorImpl Linux为PollSelectorImpl) Selector同时会初始化并持有PollArrayWapper类(功能近似于一个数组，保存注册的Socket句柄、感兴趣的事件掩码以及调用系统调用poll后的返回的就绪事件掩码)ServerSocketChannel.open 初始化channel，构造ServerSocketChannelImpl 对象ServerSocketChannel.register 注册需要监听的通道 将channel(socket)以及感兴趣的事件注册到pollArray中 Selector.select 获取已经就绪的通道 以Linux为例： Selector.open1234public static Selector open() throws IOException &#123; return SelectorProvider.provider().openSelector();&#125; 从上可知Selecotr是由SelectorProvider.openSelector提供。则要初始化Selector必须先拿到SelectorProvier。 获取SelectorProvider1234567891011121314151617public static SelectorProvider provider() &#123; synchronized (lock) &#123; if (provider != null) return provider; return AccessController.doPrivileged( new PrivilegedAction&lt;SelectorProvider&gt;() &#123; public SelectorProvider run() &#123; if (loadProviderFromProperty()) return provider; if (loadProviderAsService()) return provider; provider = sun.nio.ch.DefaultSelectorProvider.create(); return provider; &#125; &#125;); &#125;&#125; 通过获取系统变量java.nio.channels.spi.SelectorProvider的方式获取SelectorProvider 通过SPI扩展加载获取SelectorProvider 通过sun.nio.ch.DefaultSelectorProvider.create()获取 不一样的DefaultSelectorProvider通过阅读JDK源码 我们可以找到linux、macosx、windows三个版本的实现 linux版本： 12345678910111213141516171819202122232425262728293031323334public class DefaultSelectorProvider &#123; /** * Prevent instantiation. */ private DefaultSelectorProvider() &#123; &#125; @SuppressWarnings("unchecked") private static SelectorProvider createProvider(String cn) &#123; Class&lt;SelectorProvider&gt; c; try &#123; c = (Class&lt;SelectorProvider&gt;)Class.forName(cn); &#125; catch (ClassNotFoundException x) &#123; throw new AssertionError(x); &#125; try &#123; return c.newInstance(); &#125; catch (IllegalAccessException | InstantiationException x) &#123; throw new AssertionError(x); &#125; &#125; /** * Returns the default SelectorProvider. */ public static SelectorProvider create() &#123; String osname = AccessController .doPrivileged(new GetPropertyAction("os.name")); if (osname.equals("SunOS")) return createProvider("sun.nio.ch.DevPollSelectorProvider"); if (osname.equals("Linux")) return createProvider("sun.nio.ch.EPollSelectorProvider"); return new sun.nio.ch.PollSelectorProvider(); &#125;&#125; macosx版本： 12345678910111213public class DefaultSelectorProvider &#123; /** * Prevent instantiation. */ private DefaultSelectorProvider() &#123; &#125; /** * Returns the default SelectorProvider. */ public static SelectorProvider create() &#123; return new sun.nio.ch.KQueueSelectorProvider(); &#125;&#125; windows版本： 12345678910111213public class DefaultSelectorProvider &#123; /** * Prevent instantiation. */ private DefaultSelectorProvider() &#123; &#125; /** * Returns the default SelectorProvider. */ public static SelectorProvider create() &#123; return new sun.nio.ch.WindowsSelectorProvider(); &#125;&#125; 以Linux为例 我们来接着一探究竟，通过源码可知Linux使用的Provider为：EPollSelectorProvider EPollSelectorProvider12345678910public class EPollSelectorProvider extends SelectorProviderImpl&#123; public AbstractSelector openSelector() throws IOException &#123; return new EPollSelectorImpl(this); &#125; public Channel inheritedChannel() throws IOException &#123; return InheritedChannel.getChannel(); &#125;&#125; 显然Linux下 Selector selector = Selector.open()最终初始化了一个EPollSelectorImpl对象 Selector的真身EPollSelectorImplEPollSelectorImpl初始化过程，会建立一个管道pipe 并初始化一个EPollArrayWrapper数组保存pollfd， 并初始化一个维持文件描述符与SelectorKeyImpl映射关系的map 1234567891011121314EPollSelectorImpl(SelectorProvider sp) throws IOException &#123; super(sp); //1.建立一个管道Pipe 读端fd在高32位 写端fd在低32位 long pipeFds = IOUtil.makePipe(false); fd0 = (int) (pipeFds &gt;&gt;&gt; 32); fd1 = (int) pipeFds; //2.初始化一个EPollArrayWrapper 本质上是pollfd数组 pollWrapper = new EPollArrayWrapper(); //3.将读端fd添加到PollArrayWrapper的fd数组中 pollWrapper.initInterrupt(fd0, fd1); //4.初始化文件描述符到SelectorKey映射的map //private Map&lt;Integer,SelectionKeyImpl&gt; fdToKey; fdToKey = new HashMap&lt;&gt;();&#125; 关键的EPollArrayWrapperEPollArrayWrapper实际通过JNI操作本地epoll_event的数据结构，其定义如下 1234567891011typedef union epoll_data &#123; void *ptr; int fd; __uint32_t u32; __uint64_t u64;&#125; epoll_data_t;struct epoll_event &#123; __uint32_t events; epoll_data_t data;&#125;; 12345678910111213141516EPollArrayWrapper初始化构造器，首先创建epoll的数据结构，并进行内存申请分配EPollArrayWrapper() throws IOException &#123; // creates the epoll file descriptor epfd = epollCreate(); // the epoll_event array passed to epoll_wait int allocationSize = NUM_EPOLLEVENTS * SIZE_EPOLLEVENT; pollArray = new AllocatedNativeObject(allocationSize, true); pollArrayAddress = pollArray.address(); // eventHigh needed when using file descriptors &gt; 64k if (OPEN_MAX &gt; MAX_UPDATE_ARRAY_SIZE) eventsHigh = new HashMap&lt;&gt;();&#125; epollCreate()epollCreate通过JNI调用系统方法epoll_create 并返回句柄 完成epoll的初始化工作12345678910111213JNIEXPORT jint JNICALLJava_sun_nio_ch_EPollArrayWrapper_epollCreate(JNIEnv *env, jobject this)&#123; /* * epoll_create expects a size as a hint to the kernel about how to * dimension internal structures. We can't predict the size in advance. */ int epfd = epoll_create(256); if (epfd &lt; 0) &#123; JNU_ThrowIOExceptionWithLastError(env, "epoll_create failed"); &#125; return epfd;&#125; 在上面EpollSelectorImpl初始化过程中，我们看到pollWrapper.initInterrupt(fd0, fd1);的调用12345void initInterrupt(int fd0, int fd1) &#123; outgoingInterruptFD = fd1; incomingInterruptFD = fd0; epollCtl(epfd, EPOLL_CTL_ADD, fd0, EPOLLIN);&#125; 1234567891011121314151617181920212223242526JNIEXPORT void JNICALLJava_sun_nio_ch_EPollArrayWrapper_epollCtl(JNIEnv *env, jobject this, jint epfd, jint opcode, jint fd, jint events)&#123; struct epoll_event event; int res; event.events = events; event.data.fd = fd; RESTARTABLE(epoll_ctl(epfd, (int)opcode, (int)fd, &amp;event), res); /* * A channel may be registered with several Selectors. When each Selector * is polled a EPOLL_CTL_DEL op will be inserted into its pending update * list to remove the file descriptor from epoll. The "last" Selector will * close the file descriptor which automatically unregisters it from each * epoll descriptor. To avoid costly synchronization between Selectors we * allow pending updates to be processed, ignoring errors. The errors are * harmless as the last update for the file descriptor is guaranteed to * be EPOLL_CTL_DEL. */ if (res &lt; 0 &amp;&amp; errno != EBADF &amp;&amp; errno != ENOENT &amp;&amp; errno != EPERM) &#123; JNU_ThrowIOExceptionWithLastError(env, "epoll_ctl failed"); &#125;&#125; 而epollCtl实际通过JNI调用了系统方法epoll_ctl(epfd, (int)opcode, (int)fd, &amp;event) 来将需要监听的句柄加入到epoll的数据结构中epoll_ctl函数用于管理文件描述符的事件集 使用此函数可以注册、修改、删除一个或多个事件 Selector.select()12345678910111213141516171819202122232425262728293031323334353637383940414243444546public int select(long timeout) throws IOException&#123; if (timeout &lt; 0) throw new IllegalArgumentException("Negative timeout"); return lockAndDoSelect((timeout == 0) ? -1 : timeout);&#125;private int lockAndDoSelect(long timeout) throws IOException &#123; synchronized (this) &#123; if (!isOpen()) throw new ClosedSelectorException(); synchronized (publicKeys) &#123; synchronized (publicSelectedKeys) &#123; return doSelect(timeout); &#125; &#125; &#125;&#125;protected int doSelect(long timeout) throws IOException &#123; if (closed) throw new ClosedSelectorException(); //处理已经不监听的事件(文件描述符或Channel) processDeregisterQueue(); try &#123; //标记开始一个可能被中断的IO操作 begin(); //通过调用native方法epoll_wait获取已经就绪的pollfd pollWrapper.poll(timeout); &#125; finally &#123; end(); &#125; //处理已经不监听的事件 processDeregisterQueue(); //更新有事件变化的selectorKeys int numKeysUpdated = updateSelectedKeys(); if (pollWrapper.interrupted()) &#123; // Clear the wakeup pipe pollWrapper.putEventOps(pollWrapper.interruptedIndex(), 0); synchronized (interruptLock) &#123; pollWrapper.clearInterrupted(); IOUtil.drain(fd0); interruptTriggered = false; &#125; &#125; return numKeysUpdated;&#125; Selector.select()最终调用了pollArrayWrapper.poll()方法 将已经就绪的fd添加到pollWrapper里的数组中123456789101112int poll(long timeout) throws IOException &#123; updateRegistrations(); updated = epollWait(pollArrayAddress, NUM_EPOLLEVENTS, timeout, epfd); for (int i=0; i&lt;updated; i++) &#123; if (getDescriptor(i) == incomingInterruptFD) &#123; interruptedIndex = i; interrupted = true; break; &#125; &#125; return updated;&#125;PollArrayWrapper.poll()方法通过JNI调用系统方法epoll_wait来实现 获取准备就绪的句柄12345678910111213141516171819JNIEXPORT jint JNICALLJava_sun_nio_ch_EPollArrayWrapper_epollWait(JNIEnv *env, jobject this, jlong address, jint numfds, jlong timeout, jint epfd)&#123; struct epoll_event *events = jlong_to_ptr(address); int res; if (timeout &lt;= 0) &#123; /* Indefinite or no wait */ RESTARTABLE(epoll_wait(epfd, events, numfds, timeout), res); &#125; else &#123; /* Bounded wait; bounded restarts */ res = iepoll(epfd, events, numfds, timeout); &#125; if (res &lt; 0) &#123; JNU_ThrowIOExceptionWithLastError(env, "epoll_wait failed"); &#125; return res;&#125;epoll_wait函数负责检测事件 Selector.select()最终通过EPollArrayWrapper.poll()方法获取准备就绪的fd并添加到pollWrapper数组中，然后调用updateSelectedKeys()方法更新Selector持有的Map&lt;Integer,SelectionKeyImpl&gt; fdToKey中的SelectionKeyImpl中事件状态 123456789101112131415161718192021222324private int updateSelectedKeys() &#123; int entries = pollWrapper.updated; int numKeysUpdated = 0; for (int i=0; i&lt;entries; i++) &#123; int nextFD = pollWrapper.getDescriptor(i); SelectionKeyImpl ski = fdToKey.get(Integer.valueOf(nextFD)); // ski is null in the case of an interrupt if (ski != null) &#123; int rOps = pollWrapper.getEventOps(i); if (selectedKeys.contains(ski)) &#123; if (ski.channel.translateAndSetReadyOps(rOps, ski)) &#123; numKeysUpdated++; &#125; &#125; else &#123; ski.channel.translateAndSetReadyOps(rOps, ski); if ((ski.nioReadyOps() &amp; ski.nioInterestOps()) != 0) &#123; selectedKeys.add(ski); numKeysUpdated++; &#125; &#125; &#125; &#125; return numKeysUpdated;&#125; 从pollWrapper中拿到准备就绪的fd，根据Map&lt;Integer,SelectionKeyImpl&gt; fdToKey的映射关系查到对应的SelectionKeyImpl并更新其持有Channel中事件的状态SelectionKeyImpl.channel.translateAndSetReadyOps(rOps, ski)，准备就绪的fd对应的SelectionKeyImpl会被放入SelectorImpl中的Set&lt;SelectionKey&gt; selectedKeys中，这样用户级别的API selector.selectedKes()就可以拿到准备就绪的fd 进行业务处理 ServerSocketChannel.register()ServerSocketChannel.open()会初始化ServerSocketChannelImpl对象123456789101112131415161718192021222324252627282930public final SelectionKey register(Selector sel, int ops, Object att) throws ClosedChannelException&#123; synchronized (regLock) &#123; if (!isOpen()) throw new ClosedChannelException(); if ((ops &amp; ~validOps()) != 0) throw new IllegalArgumentException(); if (blocking) throw new IllegalBlockingModeException(); SelectionKey k = findKey(sel); //如果channel和selector已经注册过 则直接添加感兴趣的事件和附件 if (k != null) &#123; k.interestOps(ops); k.attach(att); &#125; //如果没有注册过 先通过selector.register注册 if (k == null) &#123; // New registration synchronized (keyLock) &#123; if (!isOpen()) throw new ClosedChannelException(); k = ((AbstractSelector)sel).register(this, ops, att); addKey(k); &#125; &#125; return k; &#125;&#125;接下来我们来看下selector.register的注册过程 123456789101112131415161718192021222324protected final SelectionKey register(AbstractSelectableChannel ch, int ops, Object attachment)&#123; if (!(ch instanceof SelChImpl)) throw new IllegalSelectorException(); SelectionKeyImpl k = new SelectionKeyImpl((SelChImpl)ch, this); k.attach(attachment); synchronized (publicKeys) &#123; implRegister(k); &#125; k.interestOps(ops); return k;&#125;protected void implRegister(SelectionKeyImpl ski) &#123; if (closed) throw new ClosedSelectorException(); SelChImpl ch = ski.channel; int fd = Integer.valueOf(ch.getFDVal()); fdToKey.put(fd, ski); pollWrapper.add(fd); keys.add(ski);&#125; 如果未注册过调用selector.register() 构建SelectionKey 注册感兴趣事件和attachment附件 并将新建的SelectionKey添加到pollWrapper的数组中 Selector.wakeup123456789public Selector wakeup() &#123; synchronized (interruptLock) &#123; if (!interruptTriggered) &#123; pollWrapper.interrupt(); interruptTriggered = true; &#125; &#125; return this;&#125; 1234567891011121314//EPollArrayWrapperpublic Selector wakeup() &#123; synchronized (interruptLock) &#123; if (!interruptTriggered) &#123; pollWrapper.interrupt(); interruptTriggered = true; &#125; &#125; return this;&#125;public void interrupt() &#123; interrupt(outgoingInterruptFD);&#125;private static native void interrupt(int fd); EPollArrayWrapper.c123456789JNIEXPORT void JNICALLJava_sun_nio_ch_EPollArrayWrapper_interrupt(JNIEnv *env, jobject this, jint fd)&#123; int fakebuf[1]; fakebuf[0] = 1; if (write(fd, fakebuf, 1) &lt; 0) &#123; JNU_ThrowIOExceptionWithLastError(env,"write to interrupt fd failed"); &#125;&#125; linux的poll实现linux中有系统调用poll方法，定义如下： 1int poll (struct pollfd *fds, unsigned int nfds, int timeout); 上述pollfd结构体定义如下： 12345typedef struct pollfd &#123; int fd; short events; short revents;&#125; pollfd_t; int fd：一个文件描述句柄，代表一个Channel连接short events:该文件描述符感兴趣的事件，如POLLIN表示该文件描述符有读事件，POLLOUT表示该文件描述符可写。short revents：代表该文件描述符当前已有的事件，如有读事件则值为POLLIN，有读写事件则为POLLIN和POLLOUT的并集整体的意思就是：你指定了结构体列表的起始地址和要监控的结构体个数，linux系统就会为你在timeout时间内监控上述结构体列表中的文件描述符的相关事件，并把发生的事件写入到上述的short revents属性中。所以我们在执行一次poll之后，要想获取所有的发生了事件的文件描述符，则需要遍历整个pollfd列表，依次判断上述的short revents是否不等于0，不等于0代表发生了事件。 jdk的poll实现概述jdk要做的事情就是准备参数数据，然后去调用上述poll方法，这就要用到JNI来实现。jdk使用PollSelectorImpl来实现上述poll调用。3.1 pollfd参数jdk需要将java层面接收到的一个Channel连接映射到一个pollfd结构体，PollSelectorImpl针对此创建了一个AllocatedNativeObject 对象，该对象不是在堆中，它内部使用Unsafe类直接操作内存地址。它就是专门用来存放上述一个个pollfd结构体的内容，通过固定的offset来获取每个结构体的数据内容。所以在调用上述poll方法的时候，直接传递的是AllocatedNativeObject对象的内存地址注册Channel要做的事：其实就是将Channel的相关数据填充到上述AllocatedNativeObject的内存地址上，下次调用poll的时候，自然就会被监控取消Channel注册要做的事：其实就是从上述AllocatedNativeObject的内存地址上移除该Channel代表的pollfd结构体 PollSelectorImpl代码分析PollSelectorImpl的创建过程有如下2个内容1 创建了pipe，得到读写文件描述符，并注册到了PollArrayWrapper中2 创建了PollArrayWrapperPollArrayWrapper pollWrapper：内部创建了一个上述介绍的AllocatedNativeObject对象（用于存放注册的Channel），而pollWrapper则更像是一个工具类，来方便的用户操作AllocatedNativeObject对象，pollWrapper把普通的操作都转化成对内存的操作我们知道PollSelectorImpl在select过程的阻塞时间受控于所注册的Channel的事件，一旦有事件才会进行返回，没有事件的话就一直阻塞，为了可以允许手动控制这种局面的话，就额外增加了一个监控，即对pipe的读监控。对pipe的读文件描述符即fd0注册到PollArrayWrapper中的第一个位置，如果我们对pipe的写文件描述符fd1进行写数据操作，则pipe的读文件描述符必然会收到读事件，即可以使PollSelectorImpl不再阻塞，立即返回。来看下初始化注册f0的代码 123456void initInterrupt(int fd0, int fd1) &#123; interruptFD = fd1; putDescriptor(0, fd0); putEventOps(0, POLLIN); putReventOps(0, 0);&#125; 即将fd0存放到PollArrayWrapper的AllocatedNativeObject中，并关注POLLIN即读事件。并将pipe的写文件描述符保存到interruptFD属性中Selector对外提供了wakeup方法，来看下PollSelectorImpl的实现 1234public void interrupt() &#123; interrupt(interruptFD);&#125;private static native void interrupt(int fd); 这里就是对上述pipe的写文件描述符执行interrupt操作，来看看底层实现代码是： 12345678910JNIEXPORT void JNICALLJava_sun_nio_ch_PollArrayWrapper_interrupt(JNIEnv *env, jobject this, jint fd)&#123; int fakebuf[1]; fakebuf[0] = 1; if (write(fd, fakebuf, 1) &lt; 0) &#123; JNU_ThrowIOExceptionWithLastError(env, "Write to interrupt fd failed"); &#125;&#125; 这里就是简单的对pipe的写文件描述符写入数据用来触发pipe的读文件描述符的读事件而已。至此，PollSelectorImpl的初始化过程就完成了。 注册和取消注册Channel过程注册Channel其实就是向PollSelectorImpl中的PollArrayWrapper存放该Channel的fd、关注的事件信息，来看下实现代码 123456789101112131415161718192021222324protected void implRegister(SelectionKeyImpl ski) &#123; synchronized (closeLock) &#123; if (closed) throw new ClosedSelectorException(); // Check to see if the array is large enough if (channelArray.length == totalChannels) &#123; // Make a larger array int newSize = pollWrapper.totalChannels * 2; SelectionKeyImpl temp[] = new SelectionKeyImpl[newSize]; // Copy over for (int i=channelOffset; i&lt;totalChannels; i++) temp[i] = channelArray[i]; channelArray = temp; // Grow the NativeObject poll array pollWrapper.grow(newSize); &#125; channelArray[totalChannels] = ski; ski.setIndex(totalChannels); pollWrapper.addEntry(ski.channel); totalChannels++; keys.add(ski); &#125;&#125; 将channel存储到PollArrayWrapper中的AllocatedNativeObject中 123456789/** * Prepare another pollfd struct for use. */void addEntry(SelChImpl sc) &#123; putDescriptor(totalChannels, IOUtil.fdVal(sc.getFD())); putEventOps(totalChannels, 0); putReventOps(totalChannels, 0); totalChannels++;&#125; 存储的信息是：Channel的fd，关注的事件（初始是0）而channel的关注事件是后来才设置到PollArrayWrapper的AllocatedNativeObject中的 1234void putEventOps(int i, int event) &#123; int offset = SIZE_POLLFD * i + EVENT_OFFSET; pollArray.putShort(offset, (short)event);&#125; 不同的Selector实现，上述实现过程也是不一样的。再来看看取消注册Channel 12345678910111213141516171819202122232425262728293031protected void implDereg(SelectionKeyImpl ski) throws IOException &#123; // Algorithm: Copy the sc from the end of the list and put it into // the location of the sc to be removed (since order doesn't // matter). Decrement the sc count. Update the index of the sc // that is moved. int i = ski.getIndex(); assert (i &gt;= 0); if (i != totalChannels - 1) &#123; // Copy end one over it SelectionKeyImpl endChannel = channelArray[totalChannels-1]; channelArray[i] = endChannel; endChannel.setIndex(i); pollWrapper.release(i); PollArrayWrapper.replaceEntry(pollWrapper, totalChannels - 1, pollWrapper, i); &#125; else &#123; pollWrapper.release(i); &#125; // Destroy the last one channelArray[totalChannels-1] = null; totalChannels--; pollWrapper.totalChannels--; ski.setIndex(-1); // Remove the key from keys and selectedKeys keys.remove(ski); selectedKeys.remove(ski); deregister((AbstractSelectionKey)ski); SelectableChannel selch = ski.channel(); if (!selch.isOpen() &amp;&amp; !selch.isRegistered()) ((SelChImpl)selch).kill();&#125; 其实就是将最后一个直接覆盖到要删除的那个，以及更新相关数据的变化。 doSelect实现过程 123456789101112131415161718192021222324protected int doSelect(long timeout) throws IOException&#123; if (channelArray == null) throw new ClosedSelectorException(); processDeregisterQueue(); try &#123; begin(); pollWrapper.poll(totalChannels, 0, timeout); &#125; finally &#123; end(); &#125; processDeregisterQueue(); int numKeysUpdated = updateSelectedKeys(); if (pollWrapper.getReventOps(0) != 0) &#123; // Clear the wakeup pipe pollWrapper.putReventOps(0, 0); synchronized (interruptLock) &#123; IOUtil.drain(fd0); interruptTriggered = false; &#125; &#125; return numKeysUpdated;&#125; 第一步：就是处理那些取消了的Channel,即遍历Selector的Set cancelledKeys，依次调用他们的取消注册和其他逻辑第二步：就是使用pollWrapper执行poll过程，该过程即是准备好参数，然后调用linux的系统调用poll方法，如下12345int poll(int numfds, int offset, long timeout) &#123; return poll0(pollArrayAddress + (offset * SIZE_POLLFD), numfds, timeout);&#125;private native int poll0(long pollAddress, int numfds, long timeout);这里将AllocatedNativeObject的内存地址作为pollAddress，已注册的所有的Channel的数量作为numfds，timeout是用户传递的参数，然后就开始JNI调用再看下native方法实现123456789101112131415161718192021JNIEXPORT jint JNICALLJava_sun_nio_ch_PollArrayWrapper_poll0(JNIEnv *env, jobject this, jlong address, jint numfds, jlong timeout)&#123; struct pollfd *a; int err = 0; a = (struct pollfd *) jlong_to_ptr(address); if (timeout &lt;= 0) &#123; /* Indefinite or no wait */ RESTARTABLE (poll(a, numfds, timeout), err); &#125; else &#123; /* Bounded wait; bounded restarts */ err = ipoll(a, numfds, timeout); &#125; if (err &lt; 0) &#123; JNU_ThrowIOExceptionWithLastError(env, "Poll failed"); &#125; return (jint)err;&#125; 先将内存地址作为address转换成pollfd结构体地址，然后调用ipoll，在ipoll中我们就会见到linux的系统调用poll1234567891011121314151617181920212223242526272829static intipoll(struct pollfd fds[], unsigned int nfds, int timeout)&#123; jlong start, now; int remaining = timeout; struct timeval t; int diff; gettimeofday(&amp;t, NULL); start = t.tv_sec * 1000 + t.tv_usec / 1000; for (;;) &#123; int res = poll(fds, nfds, remaining); if (res &lt; 0 &amp;&amp; errno == EINTR) &#123; if (remaining &gt;= 0) &#123; gettimeofday(&amp;t, NULL); now = t.tv_sec * 1000 + t.tv_usec / 1000; diff = now - start; remaining -= diff; if (diff &lt; 0 || remaining &lt;= 0) &#123; return 0; &#125; start = now; &#125; &#125; else &#123; return res; &#125; &#125;&#125; 至此linux系统开始为上述所有的Channel进行监控事件。在发生了事件之后，会有2次遍历所有注册的Channel集合：一次就是在linux底层poll调用的时候会遍历，将产生的事件值存放到pollfd结构体的revents地址中另一次就是在java层面，获取产生的事件时，会遍历上述每一个结构体，拿到revents地址中的数据 第三步：一旦第二步返回就说明有事件或者超时了，一旦有事件，则linux的poll调用会把产生的事件遍历的赋值到poll调用指定的地址上，即我们指定的一个个pollfd结构体，映射到java对象就是PollArrayWrapper的AllocatedNativeObject，这时候我们获取事件就是遍历底层的每一个地址，拿到pollfd结构体中的revents，如果revents不为0代表发生了事件，还要与Channel关注的事件进行相&amp;操作，不为0代表发生了Channel关注的事件了，并清空pollfd结构体中的revents数据供下次使用，代码如下12345678910111213141516171819202122232425262728/** * Copy the information in the pollfd structs into the opss * of the corresponding Channels. Add the ready keys to the * ready queue. */protected int updateSelectedKeys() &#123; int numKeysUpdated = 0; // Skip zeroth entry; it is for interrupts only for (int i=channelOffset; i&lt;totalChannels; i++) &#123; int rOps = pollWrapper.getReventOps(i); if (rOps != 0) &#123; SelectionKeyImpl sk = channelArray[i]; pollWrapper.putReventOps(i, 0);//清理已有事件 if (selectedKeys.contains(sk)) &#123; if (sk.channel.translateAndSetReadyOps(rOps, sk)) &#123; numKeysUpdated++; &#125; &#125; else &#123; sk.channel.translateAndSetReadyOps(rOps, sk); if ((sk.nioReadyOps() &amp; sk.nioInterestOps()) != 0) &#123; selectedKeys.add(sk); numKeysUpdated++; &#125; &#125; &#125; &#125; return numKeysUpdated;&#125;这里就是通过指针操作直接获取对应底层结构体的revents数据。 第四步：上面提到了Selector也会注册一个fd用于监听，并且注册的位置时第一个即0，这里会取出该fd的发生事件，然后读取内容忽略掉即可，不然后仍然会触发该事件。代码如下1234567891011121314151617static native boolean drain(int fd) throws IOException;JNIEXPORT jboolean JNICALLJava_sun_nio_ch_IOUtil_drain(JNIEnv *env, jclass cl, jint fd)&#123; char buf[128]; int tn = 0; for (;;) &#123; int n = read(fd, buf, sizeof(buf)); tn += n; if ((n &lt; 0) &amp;&amp; (errno != EAGAIN)) JNU_ThrowIOExceptionWithLastError(env, "Drain"); if (n == (int)sizeof(buf)) continue; return (tn &gt; 0) ? JNI_TRUE : JNI_FALSE; &#125;&#125;]]></content>
      <categories>
        <category>IO</category>
      </categories>
      <tags>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构之Queue]]></title>
    <url>%2FJava%E9%9B%86%E5%90%88%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8BQueue%2F</url>
    <content type="text"><![CDATA[队列（queue）基本就是一个先进先出（FIFO）的数据结构。jdk自带的queue大致如下： 可以看出队列大致分为： 非阻塞队列 AbstractQueue 阻塞队列 BlockingQueue 双端队列 Deque 非阻塞队列1234567891011121314151617181920212223242526public interface Queue&lt;E&gt; extends Collection&lt;E&gt; &#123; /** * 向队列中新增一个元素，如果队列已满抛出IllegalStateException异常 */ boolean add(E e); /** * 添加一个元素并返回ture 若队列已满则返回false */ boolean offer(E e); /** * 移除并返回队列头部元素 若队列为空 则抛出一个NoSuchElementException异常 */ E remove(); /** * 移除并返回队列头部元素 若队列为空 则返回null */ E poll(); /** * 获取但不移除队列头部元素，若队列为空则抛出一个NoSuchElementException异常 */ E element(); /** * 获取但不删除队列头部元素 若队列为空 则返回null */ E peek();&#125; 阻塞队列BlockingQueue是所有阻塞队列的顶级接口，定义了一批方法规范 操作 抛异常 返回特定值 阻塞 超时 入队 add(e) offer(e)-&gt;false put(e) offer(e,timeout,unit) 出队 remove() poll()-&gt;null take() poll(timeout,unit) 检查 element() peek()-&gt;null - - 1 相关Queue源码解析： PriorityQueue ConcurrentLinkedQueue ArrayBlockingQueue LinkedBlockingQueue linkedBlockingDeque PriorityBlockingQueue DelayQueue SynchronousQueue LinkedTransferQueue]]></content>
      <categories>
        <category>Java集合</category>
      </categories>
      <tags>
        <tag>DataStructure</tag>
        <tag>Queue</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java事务那点儿事儿]]></title>
    <url>%2FTransaction%2FJava%E4%BA%8B%E5%8A%A1%E9%82%A3%E7%82%B9%E5%84%BF%E4%BA%8B%E5%84%BF%2F</url>
    <content type="text"><![CDATA[事务的定义事务是指访问并可能更新数据库中各种数据项的一个程序操作单元。 作为一个java web开发者，最早我们入门的时候应该都接触过jdbc事务： 123456789101112131415161718Connection connection = null; PreparedStatement preparedStatement = null; Class.forName("com.mysql.jdbc.Driver"); try &#123; connection = DriverManager.getConnection("jdbc:mysql://localhost/test"); connection.setAutoCommit(false); preparedStatement = connection.prepareStatement("INSERT UserInfo (username,age) VALUES (?,?)"); preparedStatement.setString(1,"Tom"); preparedStatement.setInt(2, 23); preparedStatement.execute(); connection.commit(); &#125; catch (Exception e) &#123; e.printStackTrace(); connection.rollback(); &#125;finally &#123; if (preparedStatement !=null) preparedStatement.close(); if (connection != null) connection.close(); &#125; java大致有三种事务模型，大致分为本地事务模型、编程式事务模型、声明式事务模型。 本地事务模型（Local Transaction Model）本地事务模型，是通过本地资源器（Local Resource Manager）来管理事务，而不依赖于编程框架。资源管理器是用于通信的实际的数据提供者，比如我们常用的jdbc访问数据库：其资源管理器是由数据库驱动和数据库管理系统共同来实现的。对于JMS来说，资源管理器是建立topic和queue的连接工厂。所以使用的本地事务管理模型，开发人员管理是连接而不是事务。实际的事务是由JMS和数据库管理系统的提供者来管理。 编程式事务模型（Programmatic Transaction Model）相对于本地事务模型，编程式事务模型利用JTA(Java Transaction API)以及底层的事务服务实现来提供事务的支持，更加灵活，突破种种限制。此时开发人员编程的对象是事务而不是连接了，通过javax.transaction.UserTransaction接口，调用begin()方法开始一个事务，通过commit()或rollback()方法终止这个事务。使用编程式事务模型固然很灵活，但一旦业务逻辑变得复杂管理起来便如噩梦一般，而且容易出错。但有些场景还是很有用的。 1、因为事务是非常消耗资源的，为了优化性能，有时候我们希望将一些无关的耗时较长的数据加载、校验等逻辑从事务范围内剥离出来，从而降低事务执行带来的资源消耗。2、当一个业务可能需要多次远程调用才能完成，按道理应该由客户端来开启事务，此时使用jta时，就需要使用UserTransaction接口和编程式事务，远程调用的方法使用声明式事务。 声明式事务模型（Declarative Transaction Model）声明式事务模型，使用编程框架或容器帮助完成了事务的开启、提交、回滚，开发者只需要告诉何时出现何种异常是否需要回滚即可。 事务的ACID特性ACID即，原子性（Atomicity）、一致性（Consistency）、隔离性（Isolation）、持久性（Durability）。原子性，操作的一组数据集合要么全部成功要么全部失败；一致性，保证数据库数据时刻避免数据被置于不一致的状态；隔离性，各个独立事务之间交互程度，对于同一数据访问的未提交事务直接相互不受影响；持久性，事务提交后保证修改的数据能够永久保存。 JTA与JTS随着项目规模的逐渐壮大，像JDBC这样的本地事务很快暴露出他无法跨数据库进行事务管理的弊端，面对越来越多的分布式场景，此时JTA事务就应运而生。JTA（Java Transaction API）java事务API，是开发者针对事务进行编程管理的API，允许完成跨多个XA资源的分布式事务；JTS（Java Transaction Service）被开源或商业应用服务采用，实现了JTA的底层事务服务。JTA和JTS之间的关系跟JDBC与对应的底层数据库驱动类似。我们在使用编程式事务时，我们仅仅需要使用的唯一接口为javax.transaction.UserTransaction: 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109/** * The UserTransaction interface defines the methods that allow an * application to explicitly manage transaction boundaries. */public interface UserTransaction &#123; /** * Create a new transaction and associate it with the current thread. * * @exception NotSupportedException Thrown if the thread is already * associated with a transaction and the Transaction Manager * implementation does not support nested transactions. * * @exception SystemException Thrown if the transaction manager * encounters an unexpected error condition. * */ void begin() throws NotSupportedException, SystemException; /** * Complete the transaction associated with the current thread. When this * method completes, the thread is no longer associated with a transaction. * * @exception RollbackException Thrown to indicate that * the transaction has been rolled back rather than committed. * * @exception HeuristicMixedException Thrown to indicate that a heuristic * decision was made and that some relevant updates have been committed * while others have been rolled back. * * @exception HeuristicRollbackException Thrown to indicate that a * heuristic decision was made and that all relevant updates have been * rolled back. * * @exception SecurityException Thrown to indicate that the thread is * not allowed to commit the transaction. * * @exception IllegalStateException Thrown if the current thread is * not associated with a transaction. * * @exception SystemException Thrown if the transaction manager * encounters an unexpected error condition. */ void commit() throws RollbackException, HeuristicMixedException, HeuristicRollbackException, SecurityException, IllegalStateException, SystemException; /** * Roll back the transaction associated with the current thread. When this * method completes, the thread is no longer associated with a transaction. * * @exception SecurityException Thrown to indicate that the thread is * not allowed to roll back the transaction. * * @exception IllegalStateException Thrown if the current thread is * not associated with a transaction. * * @exception SystemException Thrown if the transaction manager * encounters an unexpected error condition. * */ void rollback() throws IllegalStateException, SecurityException, SystemException; /** * Modify the transaction associated with the current thread such that * the only possible outcome of the transaction is to roll back the * transaction. * * @exception IllegalStateException Thrown if the current thread is * not associated with a transaction. * * @exception SystemException Thrown if the transaction manager * encounters an unexpected error condition. * */ void setRollbackOnly() throws IllegalStateException, SystemException; /** * Obtain the status of the transaction associated with the current thread. * * @return The transaction status. If no transaction is associated with * the current thread, this method returns the Status.NoTransaction * value. * * @exception SystemException Thrown if the transaction manager * encounters an unexpected error condition. * */ int getStatus() throws SystemException; /** * Modify the timeout value that is associated with transactions started * by the current thread with the begin method. * * &lt;p&gt; If an application has not called this method, the transaction * service uses some default value for the transaction timeout. * * @param seconds The value of the timeout in seconds. If the value is zero, * the transaction service restores the default value. If the value * is negative a SystemException is thrown. * * @exception SystemException Thrown if the transaction manager * encounters an unexpected error condition. * */ void setTransactionTimeout(int seconds) throws SystemException;&#125; 我们如果暂时挂起或者恢复一个事务，此时可以使用TransactionManager:123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162/** * The TransactionManager interface defines the methods that allow an * application server to manage transaction boundaries. */public interface TransactionManager &#123; /** * Create a new transaction and associate it with the current thread. * * @exception NotSupportedException Thrown if the thread is already * associated with a transaction and the Transaction Manager * implementation does not support nested transactions. * * @exception SystemException Thrown if the transaction manager * encounters an unexpected error condition. * */ public void begin() throws NotSupportedException, SystemException; /** * Complete the transaction associated with the current thread. When this * method completes, the thread is no longer associated with a transaction. * * @exception RollbackException Thrown to indicate that * the transaction has been rolled back rather than committed. * * @exception HeuristicMixedException Thrown to indicate that a heuristic * decision was made and that some relevant updates have been committed * while others have been rolled back. * * @exception HeuristicRollbackException Thrown to indicate that a * heuristic decision was made and that all relevant updates have been * rolled back. * * @exception SecurityException Thrown to indicate that the thread is * not allowed to commit the transaction. * * @exception IllegalStateException Thrown if the current thread is * not associated with a transaction. * * @exception SystemException Thrown if the transaction manager * encounters an unexpected error condition. * */ public void commit() throws RollbackException, HeuristicMixedException, HeuristicRollbackException, SecurityException, IllegalStateException, SystemException; /** * Obtain the status of the transaction associated with the current thread. * * @return The transaction status. If no transaction is associated with * the current thread, this method returns the Status.NoTransaction * value. * * @exception SystemException Thrown if the transaction manager * encounters an unexpected error condition. * */ public int getStatus() throws SystemException; /** * Get the transaction object that represents the transaction * context of the calling thread. * * @return the &lt;code&gt;Transaction&lt;/code&gt; object representing the * transaction associated with the calling thread. * * @exception SystemException Thrown if the transaction manager * encounters an unexpected error condition. * */ public Transaction getTransaction() throws SystemException; /** * Resume the transaction context association of the calling thread * with the transaction represented by the supplied Transaction object. * When this method returns, the calling thread is associated with the * transaction context specified. * * @param tobj The &lt;code&gt;Transaction&lt;/code&gt; object that represents the * transaction to be resumed. * * @exception InvalidTransactionException Thrown if the parameter * transaction object contains an invalid transaction. * * @exception IllegalStateException Thrown if the thread is already * associated with another transaction. * * @exception SystemException Thrown if the transaction manager * encounters an unexpected error condition. */ public void resume(Transaction tobj) throws InvalidTransactionException, IllegalStateException, SystemException; /** * Roll back the transaction associated with the current thread. When this * method completes, the thread is no longer associated with a * transaction. * * @exception SecurityException Thrown to indicate that the thread is * not allowed to roll back the transaction. * * @exception IllegalStateException Thrown if the current thread is * not associated with a transaction. * * @exception SystemException Thrown if the transaction manager * encounters an unexpected error condition. * */ public void rollback() throws IllegalStateException, SecurityException, SystemException; /** * Modify the transaction associated with the current thread such that * the only possible outcome of the transaction is to roll back the * transaction. * * @exception IllegalStateException Thrown if the current thread is * not associated with a transaction. * * @exception SystemException Thrown if the transaction manager * encounters an unexpected error condition. * */ public void setRollbackOnly() throws IllegalStateException, SystemException; /** * Modify the timeout value that is associated with transactions started * by the current thread with the begin method. * * &lt;p&gt; If an application has not called this method, the transaction * service uses some default value for the transaction timeout. * * @param seconds The value of the timeout in seconds. If the value is zero, * the transaction service restores the default value. If the value * is negative a SystemException is thrown. * * @exception SystemException Thrown if the transaction manager * encounters an unexpected error condition. * */ public void setTransactionTimeout(int seconds) throws SystemException; /** * Suspend the transaction currently associated with the calling * thread and return a Transaction object that represents the * transaction context being suspended. If the calling thread is * not associated with a transaction, the method returns a null * object reference. When this method returns, the calling thread * is not associated with a transaction. * * @return Transaction object representing the suspended transaction. * * @exception SystemException Thrown if the transaction manager * encounters an unexpected error condition. * */ public Transaction suspend() throws SystemException;&#125; 并不是使用UserTransaction或者TransactionManager就将JDBC这样的本地事务转换成JTA事务，JTA事务要求Connection、DataSource、Resource必须符合XA规范，并实现了XA规范的接口才能参与到JTA事务当中（目前主流的数据库都支持XA规范）；也即要想使用JTA事务，需要有一个实现了javax.sql.XAConnection、javax.sql.XADataSource、javax.transaction.xa.XAResource的JDBC驱动程序，XADataSource相当于XAConnection的对象工厂，使用JTA事务，必须使用XADataSource获取一个XAConnection对象作为XA连接。XA连接（javax.sql.XAConnection）与非XA连接（javax.sql.Connection）区别在于，XA连接可以参与JTA事务并不支持自动提交。 JTA事务优点很明显支持了分布式事务，缺点是实现复杂，JTA UserTransaction通常需要利用JDNI来获取，即需要同时使用JTA和JNDI 虽然JTA是java提供的一套支持分布式事务的API，但是不同的J2EE平台的实现也不一样所以使用起来也不方便。 因为JTA事务的复杂性，目前业界只要的分布式事务解决方案主要有异步消息确保型、TCC、最大努力通知等。 标准的分布式事务一个标准的分布式事务包括一个事务管理器和一个或多个资源管理器（资源管理器是任意的持久化数据存储），事务管理器承担着参与事务的成员之间的通信职责。 JTA 深度历险-原理与实现 https://www.ibm.com/developerworks/cn/java/j-lo-jta/]]></content>
      <categories>
        <category>Transaction</category>
      </categories>
      <tags>
        <tag>Transaction</tag>
        <tag>事务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[免费的https证书]]></title>
    <url>%2Fnetwork%2F%E5%85%8D%E8%B4%B9%E7%9A%84https%E8%AF%81%E4%B9%A6%2F</url>
    <content type="text"><![CDATA[从网景创建SSL协议到目前的TLS 3.0已经有24个年头了，随着互联网的迅猛发展，现在主流的公司也纷纷进行了全站https的改造。跟随这波热潮也尝试了下应用https/http2.0，这里介绍下如何使用Let’s Encrypt签发免费的证书。 生成Let’s Encrypt证书talk is cheap,show me code:123git clone https://github.com/letsencrypt/letsencryptcd letsencrypt./letsencrypt-auto certonly --standalone -d relottery.cn 命令执行完毕会出现提示：MPORTANT NOTES: Congratulations! Your certificate and chain have been saved at:/etc/letsencrypt/live/relottery.cn/fullchain.pemYour key file has been saved at:/etc/letsencrypt/live/relottery.cn/privkey.pemYour cert will expire on 2018-04-18. To obtain a new or tweakedversion of this certificate in the future, simply runletsencrypt-auto again. To non-interactively renew all of yourcertificates, run “letsencrypt-auto renew” 大功告成，在/etc/letsencrypt/live/relottery.cn/目录下会生成秘钥证书文件：1234cert.pem - Apache服务器端证书chain.pem - Apache根证书和中继证书fullchain.pem - Nginx所需要ssl_certificate文件privkey.pem - 安全证书KEY文件 这里我使用的nginx，所以我需要fullchain.pem和privkey.pem两个文件做如下配置：12ssl_certificate /etc/letsencrypt/live/relottery.cn/fullchain.pem;ssl_certificate_key /etc/letsencrypt/live/relottery.cn/privkey.pem; 细心的同学会发现，上面提示我们证书是存在有效期的(90天)，如果过期再手动去执行太蠢了，show the code： 1234crontab -e 30 2 * * 1 /home/app/letsencrypt/letsencrypt/letsencrypt-auto renew35 2 * * 1 /home/app/openresty/nginx/sbin/nginx -s reload done. 遇到的问题/home/app/letsencrypt/letsencrypt/letsencrypt-auto renewWARNING: unable to check for updates.Creating virtual environment…Installing Python packages…Had a problem while installing Python packages.pip prints the following errors: Collecting argparse==1.4.0 (from -r /tmp/tmp.Xf3AdlgJol/letsencrypt-auto-requirements.txt (line 11)) Downloading http://mirrors.aliyun.com/pypi/packages/f2/94/3af39d34be01a24a6e65433d19e107099374224905f1e0cc6bbe1fd22a2f/argparse-1.4.0-py2.py3-none-any.whl Downloading http://mirrors.aliyun.com/pypi/packages/fd/21/0c6f33829fadec8aca0c1ebb4d6f8101c05899356a58d1b2e506cb77cf18/letsencrypt-0.7.0-py2-none-any.whl Collecting certbot==0.21.0 (from -r /tmp/tmp.Xf3AdlgJol/letsencrypt-auto-requirements.txt (line 206)) Could not find a version that satisfies the requirement certbot==0.21.0 (from -r /tmp/tmp.Xf3AdlgJol/letsencrypt-auto-requirements.txt (line 206)) (from versions: 0.6.0, 0.7.0, 0.8.0, 0.8.1, 0.9.0, 0.9.1, 0.9.2, 0.9.3, 0.10.0, 0.10.1, 0.10.2, 0.11.0, 0.11.1, 0.12.0, 0.13.0, 0.14.0, 0.14.1, 0.14.2, 0.15.0, 0.16.0, 0.17.0, 0.18.0, 0.18.1, 0.18.2, 0.19.0, 0.20.0)No matching distribution found for certbot==0.21.0 (from -r /tmp/tmp.Xf3AdlgJol/letsencrypt-auto-requirements.txt (line 206)) Certbot has problem setting up the virtual environment.We were not be able to guess the right solution from your pipoutput.Consult https://certbot.eff.org/docs/install.html#problems-with-python-virtual-environmentfor possible solutions.You may also find some support resources at https://certbot.eff.org/support/ . 本来挺信任阿里云的pip源的 哎 果断换之：~/.pip/pip.conf1234[global]index-url=https://pypi.tuna.tsinghua.edu.cn/simple[install]trusted-host=pypi.tuna.tsinghua.edu.cn 国内的pip镜像阿里云 http://mirrors.aliyun.com/pypi/simple/中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/豆瓣(douban) http://pypi.douban.com/simple/清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/]]></content>
      <categories>
        <category>network</category>
      </categories>
      <tags>
        <tag>network</tag>
        <tag>https</tag>
      </tags>
  </entry>
</search>
